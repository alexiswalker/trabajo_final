f = open('input.txt', 'r')
d1 = dict()    #словарь для хранения количества голосов партий
d2 = dict()    #словарь для хранения сколько будет отданно мест опредёленной партии
d3 = dict()      #словарь для хранения остатков от деления на "первое изб. частное"
l = set()       #сет для хранения остатков (пригодится для упорядочивания остатков по убыванию)
z = list()   #сюда перекинем данные из сета выше, чтобы их можно было упорядочить
s = ''       #строка для реализации нормального считывания имени партии
x = list() #список с именами партий в том порядке, котором нам их дают (ГЛАВНАЯ ЗАГВОСТКА)
sum = 0   #сперва - сумма всех голосов за партии, потом - сумма отданных мест
for i in f: #бежим построчно по файлу с данными
  a = i.split()   #сплитим строку чтобы отдельно считать имя партии и кол-во голосов
  for j in range(len(a) - 1):     #длина а минус 1, чтобы не захватить голоса за партию
    s = s + a[j] + ' '         #собираем строку с названием партии
  s = s[0:len(s)-1]     #срезаем лишний пробел в конце строки
  x.append(s)         #вносим название партии в список (в каком порядке ввели - в таком вывели)
  d1[s] = int(a[len(a)-1])   #вносим данные в первый словарь
  sum = sum + int(a[len(a)-1])    #считаем сумму всех голосов
  k = sum / 450    #считаем первое изб. частное
  s = ''        #обнуляем строку, чтобы использовать при повторении цикла выше
 
sum = 0         #обнуляем сумму, чтобы использовать эту переменную как кол-во отданных мест
for i in d1.keys():     #цикл распределения мест и подсчёта остатков от деления
  d2[i] = int(d1[i] // k)    #вносим во второй словарь данные об отданных местах определённой партии
  sum = sum + d2[i]   #считаем сумму отданных мест в первом этапе
  d3[i] = d1[i] % k   #вносим в третий словарь остатки от деления на первое изб. частное
  l.add(d3[i])    #заполняем сет остатками, чтобы потом упопрядочить по убыванию (используем сет, чтобы не было повторений одинаковых остатков)
 
for i in l:   #цикл переноса данных из сета с остатками в список, чтобы потом упорядочить последний
  z.append(i)
z = sorted(z)
 
while sum < 450:    #цикл второго этапа (если отданных мест в итоге меньше 450)
  for i in range(len(z)-1, -1, -1):     #бежим по списку с остатками в обратном порядке (от большего к меньшему)
    for j in d3.keys():   #бежим по третьему словарю с остатками
      if (sum < 450) and (d3[j] == z[i]):   #сравниваем наибольший остаток и остаток в третьем словаре
        d2[j] = d2[j] + 1   #если нанешний остаток в третьем словаре совпадает с нынешним наибольшим, то прибавляем этой партии ещё одно место
        sum = sum + 1   #увеличиваем общее количество отданных мест на 1
       
for i in x:   #цикл вывода данных, бежим по x, в котором хранятся названия партий в том порядке, в котором нам их дали
  print(i, d2[i])   #выводим эту нехорошую штуку
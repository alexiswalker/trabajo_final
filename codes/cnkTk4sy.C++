#include <iostream>
using namespace std;

struct Node //Звено дерева
{
   int Data; //То, что записываем в дерево
   Node *Left,*Right; //Это указатели на новые звенья
};

void Show(Node *&Tree) //Функция обхода
{
	if (Tree!= NULL) //Пока не встретится пустое звено
	{
	   Show(Tree->Left); //Рекурсивная функция для вывода левого поддерева
	   cout<<Tree->Data; //Отображаем корень дерева
	   Show(Tree->Right); //Рекурсивная функци для вывода правого поддерева
	}
}

/*Добавили очистку памяти*/
void Delete(Node *&Tree){
   if (Tree!=NULL) //Пока не встретится пустое звено
	{
	   Delete(Tree->Left); //Рекурсивная функция прохода по левому поддереву
	   Delete(Tree->Right); //Рекурсивная функци для прохода по правому поддереву
	   delete Tree; //Убиваем конечный элемент дерева
	   Tree = NULL; //Может и не обязательно, но плохого не будет
	}

}

void Add_node(int Data,Node *&MyTree) //Фукция добавления звена в дерево
{
	if (NULL==MyTree)  //То, о чем я в самом начале писал. Если дерева нет, то ложим семечко
	{
		MyTree=new Node; //Выделяем память под звено дерева
		MyTree->Data=Data; //Записываем данные в звено
		MyTree->Left=MyTree->Right=NULL; //Подзвенья инициализируем пустотой во избежание ошибок
	}

                   if (Data<MyTree->Data)   //Если нововведенный элемент x меньше чем элемент x из семечка дерева, уходим влево
                      {
                          if (MyTree->Left!=NULL) Add_node(Data,MyTree->Left); //При помощи рекурсии заталкиваем элемент на свободный участок
                          else //Если элемент получил свой участок, то
                          {
                              MyTree->Left=new Node;  //Выделяем память левому подзвену. Именно подзвену, а не просто звену
                              MyTree->Left->Left=MyTree->Left->Right=NULL; //У левого подзвена будут свои левое и правое подзвенья, инициализируем их пустотой
                              MyTree->Left->Data=Data; //Записываем в левое подзвено записываемый элемент
                          }
                      }

                    if (Data>MyTree->Data)   //Если нововведенный элемент x больше чем элемент x из семечка дерева, уходим вправо
                      {
                          if (MyTree->Right!=NULL) Add_node(Data,MyTree->Right); //При помощи рекурсии заталкиваем элемент на свободный участок
                          else //Если элемент получил свой участок, то
                          {
                              MyTree->Right=new Node;  //Выделяем память правому подзвену. Именно подзвену, а не просто звену
                              MyTree->Right->Left=MyTree->Right->Right=NULL; //У правого подзвена будут свои левое и правое подзвенья, инициализируем их пустотой
                              MyTree->Right->Data=Data; //Записываем в правое подзвено записываемый элемент
                          }
                      }
}

int main()
{
   Node *Tree=NULL;  //Создаю указатель, тип которого = звено дерева и инициализирую его пустотой
	  for (int i=5;i>0;i--) Add_node(i,Tree); //Это я забивал 5-4-3-2-1, а вывод сами увидите
	 Show(Tree); //Вывод на экран дерева. или просто обход дерева
	 cout << '\n';
	  Delete(Tree);
}
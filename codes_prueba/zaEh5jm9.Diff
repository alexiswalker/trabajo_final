diff --git a/cinder/api/contrib/identity.py b/cinder/api/contrib/identity.py
new file mode 100644
index 000000000..cf3e7ae5a
--- /dev/null
+++ b/cinder/api/contrib/identity.py
@@ -0,0 +1,54 @@
+# Copyright 2017 IBM
+#
+# Licensed under the Apache License, Version 2.0 (the "License"); you may
+# not use this file except in compliance with the License. You may obtain
+# a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+# License for the specific language governing permissions and limitations
+# under the License.
+
+from keystoneauth1 import exceptions as kse
+from keystoneauth1 import session
+from oslo_log import log as logging
+import webob
+
+from cinder.i18n import _, _LW
+
+
+LOG = logging.getLogger(__name__)
+
+
+def get_project(context, project_id):
+    """get project by id, also checks that user has access to project.
+
+    This attempts to load a project by id. If there is no project,
+    an HTTPBadRequest is emitted.
+
+    """
+    sess = session.Session(auth=context.get_auth_plugin())
+    try:
+        resp = sess.get('/projects/%s' % project_id,
+                        endpoint_filter={'service_type': 'identity'},
+                        raise_exc=False)
+    except kse.ClientException:
+        raise webob.exc.HTTPBadRequest(
+            explanation=_("Unable to contact keystone to verify project_id"))
+
+    if resp.status_code == 200:
+        # All is good with this 20x status
+        return resp.json()['project']
+    else:
+        LOG.error(
+            _LW("Unexpected response from keystone trying to "
+                "verify project_id %(pid)s - resp: %(code)s %(content)s"),
+            {"pid": project_id,
+             "code": resp.status_code,
+             "content": resp.content})
+
+        raise webob.exc.HTTPBadRequest(
+            explanation=_("Project ID %s is not accessible.") % project_id)
diff --git a/cinder/api/contrib/quotas.py b/cinder/api/contrib/quotas.py
index a03384ff1..e5579b567 100644
--- a/cinder/api/contrib/quotas.py
+++ b/cinder/api/contrib/quotas.py
@@ -15,27 +15,38 @@
 
 import webob
 
-from oslo_utils import strutils
-
 from cinder.api import extensions
+from cinder.api.contrib import identity
 from cinder.api.openstack import wsgi
 from cinder import db
-from cinder.db.sqlalchemy import api as sqlalchemy_api
 from cinder import exception
 from cinder.i18n import _
 from cinder import quota
-from cinder import quota_utils
 from cinder import utils
 
+from oslo_config import cfg
+
+CONF = cfg.CONF
 QUOTAS = quota.QUOTAS
 NON_QUOTA_KEYS = ['tenant_id', 'id']
 
-authorize_update = extensions.extension_authorizer('volume', 'quotas:update')
-authorize_show = extensions.extension_authorizer('volume', 'quotas:show')
-authorize_delete = extensions.extension_authorizer('volume', 'quotas:delete')
+QUOTA_ROOT = 'volume_extension:quotas:%s'
 
 
 class QuotaSetsController(wsgi.Controller):
+    def _get_target(self, context, project_id):
+        project = identity.get_project(context, project_id)
+        return {
+            'project_id': project['id'],
+            'project_parent_id': project['parent_id'],
+        }
+
+    def _get_parent_id(self, target):
+        # we ignore quota check for default domain
+        parent_id = target['project_parent_id']
+        if parent_id == 'default':
+            return None
+        return parent_id
 
     def _format_quota_set(self, project_id, quota_set):
         """Convert the quota object to a result dict."""
@@ -50,8 +61,6 @@ class QuotaSetsController(wsgi.Controller):
             return
         v = quota_values.get(key, {})
         used = (v.get('in_use', 0) + v.get('reserved', 0))
-        if QUOTAS.using_nested_quotas():
-            used += v.get('allocated', 0)
         if value < used:
             # TODO(mc_nair): after N opens, update error message to include
             # the current usage and requested limit
@@ -59,94 +68,44 @@ class QuotaSetsController(wsgi.Controller):
                     "resources.") % key
             raise webob.exc.HTTPBadRequest(explanation=msg)
 
-    def _get_quotas(self, context, id, usages=False):
-        values = QUOTAS.get_project_quotas(context, id, usages=usages)
+    def _validate_quota_limit(self, quota, key, project_quotas=None,
+                              parent_project_quotas=None):
+        limit = utils.validate_integer(
+            quota[key], key, min_value=-1, max_value=db.MAX_INT)
 
-        if usages:
-            return values
-        else:
-            return {k: v['limit'] for k, v in values.items()}
+        if parent_project_quotas:
+            parent_limit = parent_project_quotas[key]['limit']
+            if parent_limit == -1:
+                # parent is unlimited
+                return limit
 
-    def _authorize_update_or_delete(self, context_project,
-                                    target_project_id,
-                                    parent_id):
-        """Checks if update or delete are allowed in the current hierarchy.
+            free_quota = (parent_project_quotas[key]['limit'] -
+                          parent_project_quotas[key]['in_use'] -
+                          parent_project_quotas[key]['reserved'] -
+                          parent_project_quotas[key]['allocated'])
 
-        With hierarchical projects, only the admin of the parent or the root
-        project has privilege to perform quota update and delete operations.
+            current = 0
+            if project_quotas.get(key):
+                current = project_quotas[key]['limit']
 
-        :param context_project: The project in which the user is scoped to.
-        :param target_project_id: The id of the project in which the
-                                  user want to perform an update or
-                                  delete operation.
-        :param parent_id: The parent id of the project in which the user
-                          want to perform an update or delete operation.
-        """
-        if context_project.is_admin_project:
-            # The calling project has admin privileges and should be able
-            # to operate on all quotas.
-            return
-        if context_project.parent_id and parent_id != context_project.id:
-            msg = _("Update and delete quota operations can only be made "
-                    "by an admin of immediate parent or by the CLOUD admin.")
-            raise webob.exc.HTTPForbidden(explanation=msg)
-
-        if context_project.id != target_project_id:
-            if not self._is_descendant(target_project_id,
-                                       context_project.subtree):
-                msg = _("Update and delete quota operations can only be made "
-                        "to projects in the same hierarchy of the project in "
-                        "which users are scoped to.")
-                raise webob.exc.HTTPForbidden(explanation=msg)
+            if limit == -1 and current != -1:
+                msg = (_("Quota limit for %s "
+                         "cannot be unlimited since parent has limit.") % key)
+                raise webob.exc.HTTPBadRequest(explanation=msg)
+
+            if limit - current > free_quota:
+                msg = _("Free quota available is %s.") % free_quota
+                raise webob.exc.HTTPBadRequest(explanation=msg)
+        return limit
+
+    def _get_quotas(self, context, id, usages=False, parent_project_id=None):
+        values = QUOTAS.get_project_quotas(context, id, usages=usages,
+                                           parent_project_id=parent_project_id)
+
+        if usages:
+            return values
         else:
-            msg = _("Update and delete quota operations can only be made "
-                    "by an admin of immediate parent or by the CLOUD admin.")
-            raise webob.exc.HTTPForbidden(explanation=msg)
-
-    def _authorize_show(self, context_project, target_project):
-        """Checks if show is allowed in the current hierarchy.
-
-        With hierarchical projects, users are allowed to perform a quota show
-        operation if they have the cloud admin role or if they belong to at
-        least one of the following projects: the target project, its immediate
-        parent project, or the root project of its hierarchy.
-
-        :param context_project: The project in which the user
-                                is scoped to.
-        :param target_project: The project in which the user wants
-                               to perform a show operation.
-        """
-        if context_project.is_admin_project:
-            # The calling project has admin privileges and should be able
-            # to view all quotas.
-            return
-        if target_project.parent_id:
-            if target_project.id != context_project.id:
-                if not self._is_descendant(target_project.id,
-                                           context_project.subtree):
-                    msg = _("Show operations can only be made to projects in "
-                            "the same hierarchy of the project in which users "
-                            "are scoped to.")
-                    raise webob.exc.HTTPForbidden(explanation=msg)
-                if context_project.id != target_project.parent_id:
-                    if context_project.parent_id:
-                        msg = _("Only users with token scoped to immediate "
-                                "parents or root projects are allowed to see "
-                                "its children quotas.")
-                        raise webob.exc.HTTPForbidden(explanation=msg)
-        elif context_project.parent_id:
-            msg = _("An user with a token scoped to a subproject is not "
-                    "allowed to see the quota of its parents.")
-            raise webob.exc.HTTPForbidden(explanation=msg)
-
-    def _is_descendant(self, target_project_id, subtree):
-        if subtree is not None:
-            for key, value in subtree.items():
-                if key == target_project_id:
-                    return True
-                if self._is_descendant(target_project_id, value):
-                    return True
-        return False
+            return {k: v['limit'] for k, v in values.items()}
 
     def show(self, req, id):
         """Show quota for a particular tenant
@@ -157,37 +116,20 @@ class QuotaSetsController(wsgi.Controller):
         a show.
 
         :param req: request
-        :param id: target project id that needs to be shown
+        :param id: target project id that needs to be updated
         """
         context = req.environ['cinder.context']
-        authorize_show(context)
         params = req.params
         target_project_id = id
+        target = self._get_target(context, target_project_id)
+        context.can(QUOTA_ROOT % 'show', target)
 
         if not hasattr(params, '__call__') and 'usage' in params:
             usage = utils.get_bool_param('usage', params)
         else:
             usage = False
-
-        if QUOTAS.using_nested_quotas():
-            # With hierarchical projects, only the admin of the current project
-            # or the root project has privilege to perform quota show
-            # operations.
-            target_project = quota_utils.get_project_hierarchy(
-                context, target_project_id)
-            context_project = quota_utils.get_project_hierarchy(
-                context, context.project_id, subtree_as_ids=True,
-                is_admin_project=context.is_admin)
-
-            self._authorize_show(context_project, target_project)
-
-        try:
-            sqlalchemy_api.authorize_project_context(context,
-                                                     target_project_id)
-        except exception.NotAuthorized:
-            raise webob.exc.HTTPForbidden()
-
-        quotas = self._get_quotas(context, target_project_id, usage)
+        quotas = self._get_quotas(context, target_project_id, usage,
+                                  parent_project_id=self._get_parent_id(target))
         return self._format_quota_set(target_project_id, quotas)
 
     def update(self, req, id, body):
@@ -204,7 +146,9 @@ class QuotaSetsController(wsgi.Controller):
                      succeeds
         """
         context = req.environ['cinder.context']
-        authorize_update(context)
+        target_project_id = id
+        target = self._get_target(context, target_project_id)
+        context.can(QUOTA_ROOT % 'update', target)
         self.validate_string_length(id, 'quota_set_name',
                                     min_length=1, max_length=255)
 
@@ -212,19 +156,17 @@ class QuotaSetsController(wsgi.Controller):
 
         # Get the optional argument 'skip_validation' from body,
         # if skip_validation is False, then validate existing resource.
-        skip_flag = body.get('skip_validation', True)
-        if not utils.is_valid_boolstr(skip_flag):
-            msg = _("Invalid value '%s' for skip_validation.") % skip_flag
-            raise exception.InvalidParameterValue(err=msg)
-        skip_flag = strutils.bool_from_string(skip_flag)
+        if 'skip_validation' in body:
+            skip_flag = utils.get_bool_param('skip_validation', body)
+        else:
+            skip_flag = True
 
-        target_project_id = id
         bad_keys = []
 
         # NOTE(ankit): Pass #1 - In this loop for body['quota_set'].items(),
         # we figure out if we have any bad keys.
         for key, value in body['quota_set'].items():
-            if (key not in QUOTAS and key not in NON_QUOTA_KEYS):
+            if key not in QUOTAS and key not in NON_QUOTA_KEYS:
                 bad_keys.append(key)
                 continue
 
@@ -232,24 +174,15 @@ class QuotaSetsController(wsgi.Controller):
             msg = _("Bad key(s) in quota set: %s") % ",".join(bad_keys)
             raise webob.exc.HTTPBadRequest(explanation=msg)
 
-        # Saving off this value since we need to use it multiple times
-        use_nested_quotas = QUOTAS.using_nested_quotas()
-        if use_nested_quotas:
-            # Get the parent_id of the target project to verify whether we are
-            # dealing with hierarchical namespace or non-hierarchical namespace
-            target_project = quota_utils.get_project_hierarchy(
-                context, target_project_id, parents_as_ids=True)
-            parent_id = target_project.parent_id
+        # Get the parent_id of the target project to verify whether we are
+        # dealing with hierarchical namespace or non-hierarchical namespace.
+        parent_id = self._get_parent_id(target)
 
-            if parent_id:
-                # Get the children of the project which the token is scoped to
-                # in order to know if the target_project is in its hierarchy.
-                context_project = quota_utils.get_project_hierarchy(
-                    context, context.project_id, subtree_as_ids=True,
-                    is_admin_project=context.is_admin)
-                self._authorize_update_or_delete(context_project,
-                                                 target_project.id,
-                                                 parent_id)
+        if parent_id:
+            # Get the children of the project which the token is scoped to in
+            # order to know if the target_project is in its hierarchy.
+            parent_project_quotas = QUOTAS.get_project_quotas(
+                context, parent_id, parent_project_id=parent_id)
 
         # NOTE(ankit): Pass #2 - In this loop for body['quota_set'].keys(),
         # we validate the quota limits to ensure that we can bail out if
@@ -259,29 +192,24 @@ class QuotaSetsController(wsgi.Controller):
         quota_values = QUOTAS.get_project_quotas(context, target_project_id,
                                                  defaults=False)
         valid_quotas = {}
-        reservations = []
-        for key in body['quota_set'].keys():
+        allocated_quotas = {}
+        for key in body['quota_set']:
             if key in NON_QUOTA_KEYS:
                 continue
 
-            value = utils.validate_integer(
-                body['quota_set'][key], key, min_value=-1,
-                max_value=db.MAX_INT)
+            if parent_id:
+                value = self._validate_quota_limit(
+                    body['quota_set'], key, quota_values,
+                    parent_project_quotas)
+
+                allocated_quotas[key] = (
+                    parent_project_quotas[key]['allocated'] + value)
+            else:
+                value = self._validate_quota_limit(body['quota_set'], key)
 
-            # Can't skip the validation of nested quotas since it could mess up
-            # hierarchy if parent limit is less than childrens' current usage
-            if not skip_flag or use_nested_quotas:
+            if not skip_flag:
                 self._validate_existing_resource(key, value, quota_values)
 
-            if use_nested_quotas:
-                try:
-                    reservations += self._update_nested_quota_allocated(
-                        context, target_project, quota_values, key, value)
-                except exception.OverQuota as e:
-                    if reservations:
-                        db.reservation_rollback(context, reservations)
-                    raise webob.exc.HTTPBadRequest(explanation=e.msg)
-
             valid_quotas[key] = value
 
         # NOTE(ankit): Pass #3 - At this point we know that all the keys and
@@ -295,47 +223,24 @@ class QuotaSetsController(wsgi.Controller):
                 db.quota_create(context, target_project_id, key, value)
             except exception.AdminRequired:
                 raise webob.exc.HTTPForbidden()
+            # If hierarchical projects, update child's quota first
+            # and then parents quota. In future this needs to be an
+            # atomic operation.
+            if parent_id:
+                if key in allocated_quotas:
+                    db.quota_allocated_update(
+                        context, parent_id, key, allocated_quotas[key])
 
-        if reservations:
-            db.reservation_commit(context, reservations)
-        return {'quota_set': self._get_quotas(context, target_project_id)}
-
-    def _get_quota_usage(self, quota_obj):
-        return (quota_obj.get('in_use', 0) + quota_obj.get('allocated', 0) +
-                quota_obj.get('reserved', 0))
-
-    def _update_nested_quota_allocated(self, ctxt, target_project,
-                                       target_project_quotas, res, new_limit):
-        reservations = []
-        # per_volume_gigabytes doesn't make sense to nest
-        if res == "per_volume_gigabytes":
-            return reservations
-
-        quota_for_res = target_project_quotas.get(res, {})
-        orig_quota_from_target_proj = quota_for_res.get('limit', 0)
-        # If limit was -1, we were "taking" current child's usage from parent
-        if orig_quota_from_target_proj == -1:
-            orig_quota_from_target_proj = self._get_quota_usage(quota_for_res)
-
-        new_quota_from_target_proj = new_limit
-        # If we set limit to -1, we will "take" the current usage from parent
-        if new_limit == -1:
-            new_quota_from_target_proj = self._get_quota_usage(quota_for_res)
-
-        res_change = new_quota_from_target_proj - orig_quota_from_target_proj
-        if res_change != 0:
-            deltas = {res: res_change}
-            reservations += quota_utils.update_alloc_to_next_hard_limit(
-                ctxt, QUOTAS.resources, deltas, res, None, target_project.id)
-
-        return reservations
+        return {'quota_set': self._get_quotas(context, target_project_id,
+                                              parent_project_id=parent_id)}
 
     def defaults(self, req, id):
         context = req.environ['cinder.context']
-        authorize_show(context)
-
+        target_project_id = id
+        target = self._get_target(context, target_project_id)
+        context.can(QUOTA_ROOT % 'show', target)
         return self._format_quota_set(id, QUOTAS.get_defaults(
-            context, project_id=id))
+            context, parent_project_id=self._get_parent_id(target)))
 
     def delete(self, req, id):
         """Delete Quota for a particular tenant.
@@ -345,81 +250,45 @@ class QuotaSetsController(wsgi.Controller):
         CLOUD admin are able to perform a delete.
 
         :param req: request
-        :param id: target project id that needs to be deleted
+        :param id: target project id that needs to be updated
         """
         context = req.environ['cinder.context']
-        authorize_delete(context)
-
-        if QUOTAS.using_nested_quotas():
-            self._delete_nested_quota(context, id)
-        else:
-            try:
-                db.quota_destroy_by_project(context, id)
-            except exception.AdminRequired:
-                raise webob.exc.HTTPForbidden()
+        target_project_id = id
+        target = self._get_target(context, target_project_id)
+        context.can(QUOTA_ROOT % 'delete', target)
+        parent_id = self._get_parent_id(target)
 
-    def _delete_nested_quota(self, ctxt, proj_id):
-        # Get the parent_id of the target project to verify whether we are
-        # dealing with hierarchical namespace or non-hierarchical
-        # namespace.
         try:
             project_quotas = QUOTAS.get_project_quotas(
-                ctxt, proj_id, usages=True, defaults=False)
+                context, target_project_id, usages=True,
+                parent_project_id=parent_id)
         except exception.NotAuthorized:
             raise webob.exc.HTTPForbidden()
 
-        target_project = quota_utils.get_project_hierarchy(
-            ctxt, proj_id)
-        parent_id = target_project.parent_id
-        if parent_id:
-            # Get the children of the project which the token is scoped to
-            # in order to know if the target_project is in its hierarchy.
-            context_project = quota_utils.get_project_hierarchy(
-                ctxt, ctxt.project_id, subtree_as_ids=True)
-            self._authorize_update_or_delete(context_project,
-                                             target_project.id,
-                                             parent_id)
-
-        defaults = QUOTAS.get_defaults(ctxt, proj_id)
-        # If the project which is being deleted has allocated part of its
-        # quota to its subprojects, then subprojects' quotas should be
-        # deleted first.
-        for res, value in project_quotas.items():
-            if 'allocated' in project_quotas[res].keys():
-                if project_quotas[res]['allocated'] > 0:
-                    msg = _("About to delete child projects having "
-                            "non-zero quota. This should not be performed")
-                    raise webob.exc.HTTPBadRequest(explanation=msg)
-            # Ensure quota usage wouldn't exceed limit on a delete
-            self._validate_existing_resource(
-                res, defaults[res], project_quotas)
+        # If the project which is being deleted has allocated part of its quota
+        # to its subprojects, then subprojects' quotas should be deleted first.
+        for key, value in project_quotas.items():
+                if 'allocated' in project_quotas[key].keys():
+                    if project_quotas[key]['allocated'] != 0:
+                        msg = _("About to delete child projects having "
+                                "non-zero quota. This should not be performed")
+                        raise webob.exc.HTTPBadRequest(explanation=msg)
 
         try:
-            db.quota_destroy_by_project(ctxt, target_project.id)
+            db.quota_destroy_by_project(context, target_project_id)
         except exception.AdminRequired:
             raise webob.exc.HTTPForbidden()
 
-        for res, limit in project_quotas.items():
-            # Update child limit to 0 so the parent hierarchy gets it's
-            # allocated values updated properly
-            self._update_nested_quota_allocated(
-                ctxt, target_project, project_quotas, res, 0)
-
-    def validate_setup_for_nested_quota_use(self, req):
-        """Validates that the setup supports using nested quotas.
-
-        Ensures that Keystone v3 or greater is being used, and that the
-        existing quotas make sense to nest in the current hierarchy (e.g. that
-        no child quota would be larger than it's parent).
-        """
-        ctxt = req.environ['cinder.context']
-        params = req.params
-        try:
-            quota_utils.validate_setup_for_nested_quota_use(
-                ctxt, QUOTAS.resources, quota.NestedDbQuotaDriver(),
-                fix_allocated_quotas=params.get('fix_allocated_quotas'))
-        except exception.InvalidNestedQuotaSetup as e:
-            raise webob.exc.HTTPBadRequest(explanation=e.msg)
+        if parent_id:
+            parent_project_quotas = QUOTAS.get_project_quotas(
+                context, parent_id, parent_project_id=parent_id)
+            # Update the allocated of the parent
+            for key, value in project_quotas.items():
+                project_hard_limit = project_quotas[key]['limit']
+                parent_allocated = parent_project_quotas[key]['allocated']
+                parent_allocated -= project_hard_limit
+                db.quota_allocated_update(context, parent_id, key,
+                                          parent_allocated)
 
 
 class Quotas(extensions.ExtensionDescriptor):
@@ -427,6 +296,7 @@ class Quotas(extensions.ExtensionDescriptor):
 
     name = "Quotas"
     alias = "os-quota-sets"
+    namespace = "http://docs.openstack.org/volume/ext/quotas-sets/api/v1.1"
     updated = "2011-08-08T00:00:00+00:00"
 
     def get_resources(self):
diff --git a/cinder/context.py b/cinder/context.py
index 6d6274c83..f18d9bb6d 100644
--- a/cinder/context.py
+++ b/cinder/context.py
@@ -19,15 +19,20 @@
 
 import copy
 
+from keystoneauth1.access import service_catalog as ksa_service_catalog
+from keystoneauth1 import plugin
+
 from oslo_config import cfg
 from oslo_context import context
 from oslo_log import log as logging
 from oslo_utils import timeutils
 import six
 
+from cinder import exception
 from cinder.i18n import _, _LW
 from cinder import policy
 
+
 context_opts = [
     cfg.StrOpt('cinder_internal_tenant_project_id',
                help='ID of the project which will be used as the Cinder '
@@ -43,6 +48,31 @@ CONF.register_opts(context_opts)
 LOG = logging.getLogger(__name__)
 
 
+class _ContextAuthPlugin(plugin.BaseAuthPlugin):
+    """A keystoneauth auth plugin that uses the values from the Context.
+
+    Ideally we would use the plugin provided by auth_token middleware however
+    this plugin isn't serialized yet so we construct one from the serialized
+    auth data.
+    """
+
+    def __init__(self, auth_token, sc):
+        super(_ContextAuthPlugin, self).__init__()
+
+        self.auth_token = auth_token
+        self.service_catalog = ksa_service_catalog.ServiceCatalogV3(sc)
+
+    def get_token(self, *args, **kwargs):
+        return self.auth_token
+
+    def get_endpoint(self, session, service_type=None, interface=None,
+                     region_name=None, service_name=None, **kwargs):
+        return self.service_catalog.url_for(service_type=service_type,
+                                            service_name=service_name,
+                                            interface=interface,
+                                            region_name=region_name)
+
+
 class RequestContext(context.RequestContext):
     """Security context and request information.
 
@@ -52,7 +82,7 @@ class RequestContext(context.RequestContext):
     def __init__(self, user_id=None, project_id=None, is_admin=None,
                  read_deleted="no", project_name=None, remote_address=None,
                  timestamp=None, quota_class=None, service_catalog=None,
-                 **kwargs):
+                 user_auth_plugin=None, **kwargs):
         """Initialize RequestContext.
 
         :param read_deleted: 'no' indicates deleted records are hidden, 'yes'
@@ -90,6 +120,8 @@ class RequestContext(context.RequestContext):
             # if list is empty or none
             self.service_catalog = []
 
+        self.user_auth_plugin = user_auth_plugin
+
         # We need to have RequestContext attributes defined
         # when policy.check_is_admin invokes request logging
         # to make it loggable.
@@ -127,6 +159,12 @@ class RequestContext(context.RequestContext):
         result['request_id'] = self.request_id
         return result
 
+    def get_auth_plugin(self):
+        if self.user_auth_plugin:
+            return self.user_auth_plugin
+        else:
+            return _ContextAuthPlugin(self.auth_token, self.service_catalog)
+
     @classmethod
     def from_dict(cls, values):
         return cls(user_id=values.get('user_id'),
@@ -165,6 +203,36 @@ class RequestContext(context.RequestContext):
 
         return context
 
+    def can(self, action, target=None, fatal=True):
+        """Verifies that the given rule is valid on the target in this context.
+
+        :param action: string representing the action to be checked.
+        :param target: dictionary representing the object of the action
+            for object creation this should be a dictionary representing the
+            location of the object e.g. ``{'project_id': context.project_id}``.
+            If None, then this default target will be considered:
+            {'project_id': self.project_id, 'user_id': self.user_id}
+        :param fatal: if False, will return False when an exception.Forbidden
+           occurs.
+
+        :raises nova.exception.Forbidden: if verification fails and fatal is
+            True.
+
+        :return: returns a non-False value (not necessarily "True") if
+            authorized and False if not authorized and fatal is False.
+        """
+        if target is None:
+            target = {}
+
+        target.setdefault('project_id', self.project_id)
+        target.setdefault('user_id', self.user_id)
+        try:
+            return policy.enforce(self, action, target)
+        except exception.PolicyNotAuthorized:
+            if fatal:
+                raise
+            return False
+
     def deepcopy(self):
         return copy.deepcopy(self)
 
diff --git a/cinder/db/sqlalchemy/api.py b/cinder/db/sqlalchemy/api.py
index 12854092f..98550e6e2 100644
--- a/cinder/db/sqlalchemy/api.py
+++ b/cinder/db/sqlalchemy/api.py
@@ -845,6 +845,15 @@ def quota_allocated_update(context, project_id, resource, allocated):
         return quota_ref
 
 
+@require_admin_context
+def quota_allocated_update(context, project_id, resource, allocated):
+    session = get_session()
+    with session.begin():
+        quota_ref = _quota_get(context, project_id, resource, session=session)
+        quota_ref.allocated = allocated
+        return quota_ref
+
+
 @require_admin_context
 def quota_destroy(context, project_id, resource):
     session = get_session()
diff --git a/cinder/quota.py b/cinder/quota.py
index df077d537..14936d5d8 100644
--- a/cinder/quota.py
+++ b/cinder/quota.py
@@ -101,12 +101,17 @@ class DbQuotaDriver(object):
 
         return db.quota_class_get(context, quota_class, resource_name)
 
-    def get_default(self, context, resource, project_id):
-        """Get a specific default quota for a resource."""
+    def get_default(self, context, resource, parent_project_id=None):
+        """Get a specific default quota for a resource.
+
+        :param parent_project_id: The id of the current project's parent,
+                                  if any.
+        """
         default_quotas = db.quota_class_get_default(context)
-        return default_quotas.get(resource.name, resource.default)
+        default_quota_value = 0 if parent_project_id else resource.default
+        return default_quotas.get(resource.name, default_quota_value)
 
-    def get_defaults(self, context, resources, project_id=None):
+    def get_defaults(self, context, resources, parent_project_id=None):
         """Given a list of resources, retrieve the default quotas.
 
         Use the class quotas named `_DEFAULT_QUOTA_NAME` as default quotas,
@@ -114,7 +119,8 @@ class DbQuotaDriver(object):
 
         :param context: The request context, for access checks.
         :param resources: A dictionary of the registered resources.
-        :param project_id: The id of the current project
+        :param parent_project_id: The id of the current project's parent,
+                                  if any.
         """
 
         quotas = {}
@@ -131,8 +137,8 @@ class DbQuotaDriver(object):
                         "it is now deprecated. Please use the "
                         "default quota class for default "
                         "quota.") % {'res': resource.name})
-            quotas[resource.name] = default_quotas.get(resource.name,
-                                                       resource.default)
+            quotas[resource.name] = default_quotas.get(
+                resource.name, (0 if parent_project_id else resource.default))
         return quotas
 
     def get_class_quotas(self, context, resources, quota_class,
@@ -166,10 +172,8 @@ class DbQuotaDriver(object):
 
     def get_project_quotas(self, context, resources, project_id,
                            quota_class=None, defaults=True,
-                           usages=True):
-        """Retrieve quotas for a project.
-
-        Given a list of resources, retrieve the quotas for the given
+                           usages=True, parent_project_id=None):
+        """Given a list of resources, retrieve the quotas for the given
         project.
 
         :param context: The request context, for access checks.
@@ -184,14 +188,15 @@ class DbQuotaDriver(object):
                          default value, if there is no value from the
                          quota class) will be reported if there is no
                          specific value for the resource.
-        :param usages: If True, the current in_use, reserved and allocated
-                       counts will also be returned.
+        :param usages: If True, the current in_use and reserved counts
+                       will also be returned.
+        :param parent_project_id: The id of the current project's parent,
+                                  if any.
         """
 
         quotas = {}
         project_quotas = db.quota_get_all_by_project(context, project_id)
         allocated_quotas = None
-        default_quotas = None
         if usages:
             project_usages = db.quota_usage_get_all_by_project(context,
                                                                project_id)
@@ -210,6 +215,9 @@ class DbQuotaDriver(object):
         else:
             class_quotas = {}
 
+        default_quotas = self.get_defaults(
+            context, resources, parent_project_id=parent_project_id)
+
         for resource in resources.values():
             # Omit default/quota class values
             if not defaults and resource.name not in project_quotas:
@@ -235,12 +243,13 @@ class DbQuotaDriver(object):
                 quotas[resource.name].update(
                     in_use=usage.get('in_use', 0),
                     reserved=usage.get('reserved', 0), )
-            if allocated_quotas:
-                quotas[resource.name].update(
-                    allocated=allocated_quotas.get(resource.name, 0), )
+                if parent_project_id or allocated_quotas:
+                    quotas[resource.name].update(
+                        allocated=allocated_quotas.get(resource.name, 0), )
         return quotas
 
-    def _get_quotas(self, context, resources, keys, has_sync, project_id=None):
+    def _get_quotas(self, context, resources, keys, has_sync, project_id=None,
+                    parent_project_id=None):
         """A helper method which retrieves the quotas for specific resources.
 
         This specific resource is identified by keys, and which apply to the
@@ -256,6 +265,8 @@ class DbQuotaDriver(object):
         :param project_id: Specify the project_id if current context
                            is admin and admin wants to impact on
                            common user's tenant.
+        :param parent_project_id: The id of the current project's parent,
+                                  if any.
         """
 
         # Filter resources
@@ -275,7 +286,8 @@ class DbQuotaDriver(object):
         # Grab and return the quotas (without usages)
         quotas = self.get_project_quotas(context, sub_resources,
                                          project_id,
-                                         context.quota_class, usages=False)
+                                         context.quota_class, usages=False,
+                                         parent_project_id=parent_project_id)
 
         return {k: v['limit'] for k, v in quotas.items()}
 
@@ -447,206 +459,6 @@ class DbQuotaDriver(object):
         db.reservation_expire(context)
 
 
-class NestedDbQuotaDriver(DbQuotaDriver):
-    def validate_nested_setup(self, ctxt, resources, project_tree,
-                              fix_allocated_quotas=False):
-        """Ensures project_tree has quotas that make sense as nested quotas.
-
-        Validates the following:
-          * No parent project has child_projects who have more combined quota
-            than the parent's quota limit
-          * No child quota has a larger in-use value than it's current limit
-            (could happen before because child default values weren't enforced)
-          * All parent projects' "allocated" quotas match the sum of the limits
-            of its children projects
-
-        TODO(mc_nair): need a better way to "flip the switch" to use nested
-                       quotas to make this less race-ee
-        """
-        self._allocated = {}
-        project_queue = deque(project_tree.items())
-        borked_allocated_quotas = {}
-
-        while project_queue:
-            # Tuple of (current root node, subtree)
-            cur_proj_id, project_subtree = project_queue.popleft()
-
-            # If we're on a leaf node, no need to do validation on it, and in
-            # order to avoid complication trying to get its children, skip it.
-            if not project_subtree:
-                continue
-
-            cur_project_quotas = self.get_project_quotas(
-                ctxt, resources, cur_proj_id)
-
-            # Validate each resource when compared to it's child quotas
-            for resource in cur_project_quotas.keys():
-                parent_quota = cur_project_quotas[resource]
-                parent_limit = parent_quota['limit']
-                parent_usage = (parent_quota['in_use'] +
-                                parent_quota['reserved'])
-
-                cur_parent_allocated = parent_quota.get('allocated', 0)
-                calc_parent_allocated = self._get_cur_project_allocated(
-                    ctxt, resources[resource], {cur_proj_id: project_subtree})
-
-                if parent_limit > 0:
-                    parent_free_quota = parent_limit - parent_usage
-                    if parent_free_quota < calc_parent_allocated:
-                        msg = _("Sum of child usage '%(sum)s' is greater "
-                                "than free quota of '%(free)s' for project "
-                                "'%(proj)s' for resource '%(res)s'. Please "
-                                "lower the limit or usage for one or more of "
-                                "the following projects: '%(child_ids)s'") % {
-                            'sum': calc_parent_allocated,
-                            'free': parent_free_quota,
-                            'proj': cur_proj_id, 'res': resource,
-                            'child_ids': ', '.join(project_subtree.keys())
-                        }
-                        raise exception.InvalidNestedQuotaSetup(reason=msg)
-
-                # If "allocated" value wasn't right either err or fix DB
-                if calc_parent_allocated != cur_parent_allocated:
-                    if fix_allocated_quotas:
-                        try:
-                            db.quota_allocated_update(ctxt, cur_proj_id,
-                                                      resource,
-                                                      calc_parent_allocated)
-                        except exception.ProjectQuotaNotFound:
-                            # If it was default quota create DB entry for it
-                            db.quota_create(
-                                ctxt, cur_proj_id, resource,
-                                parent_limit, allocated=calc_parent_allocated)
-                    else:
-                        if cur_proj_id not in borked_allocated_quotas:
-                            borked_allocated_quotas[cur_proj_id] = {}
-
-                        borked_allocated_quotas[cur_proj_id][resource] = {
-                            'db_allocated_quota': cur_parent_allocated,
-                            'expected_allocated_quota': calc_parent_allocated}
-
-            project_queue.extend(project_subtree.items())
-
-        if borked_allocated_quotas:
-            msg = _("Invalid allocated quotas defined for the following "
-                    "project quotas: %s") % borked_allocated_quotas
-            raise exception.InvalidNestedQuotaSetup(message=msg)
-
-    def _get_cur_project_allocated(self, ctxt, resource, project_tree):
-        """Recursively calculates the allocated value of a project
-
-        :param ctxt: context used to retrieve DB values
-        :param resource: the resource to calculate allocated value for
-        :param project_tree: the project tree used to calculate allocated
-                e.g. {'A': {'B': {'D': None}, 'C': None}}
-
-        A project's "allocated" value depends on:
-            1) the quota limits which have been "given" to it's children, in
-               the case those limits are not unlimited (-1)
-            2) the current quota being used by a child plus whatever the child
-               has given to it's children, in the case of unlimited (-1) limits
-
-        Scenario #2 requires recursively calculating allocated, and in order
-        to efficiently calculate things we will save off any previously
-        calculated allocated values.
-
-        NOTE: this currently leaves a race condition when a project's allocated
-        value has been calculated (with a -1 limit), but then a child project
-        gets a volume created, thus changing the in-use value and messing up
-        the child's allocated value. We should look into updating the allocated
-        values as we're going along and switching to NestedQuotaDriver with
-        flip of a switch.
-        """
-        # Grab the current node
-        cur_project_id = list(project_tree)[0]
-        project_subtree = project_tree[cur_project_id]
-        res_name = resource.name
-
-        if cur_project_id not in self._allocated:
-            self._allocated[cur_project_id] = {}
-
-        if res_name not in self._allocated[cur_project_id]:
-            # Calculate the allocated value for this resource since haven't yet
-            cur_project_allocated = 0
-            child_proj_ids = project_subtree.keys() if project_subtree else {}
-            res_dict = {res_name: resource}
-            child_project_quotas = {child_id: self.get_project_quotas(
-                ctxt, res_dict, child_id) for child_id in child_proj_ids}
-
-            for child_id, child_quota in child_project_quotas.items():
-                child_limit = child_quota[res_name]['limit']
-                # Non-unlimited quota is easy, anything explicitly given to a
-                # child project gets added into allocated value
-                if child_limit != -1:
-                    if child_quota[res_name].get('in_use', 0) > child_limit:
-                        msg = _("Quota limit invalid for project '%(proj)s' "
-                                "for resource '%(res)s': limit of %(limit)d "
-                                "is less than in-use value of %(used)d") % {
-                            'proj': child_id, 'res': res_name,
-                            'limit': child_limit,
-                            'used': child_quota[res_name]['in_use']
-                        }
-                        raise exception.InvalidNestedQuotaSetup(reason=msg)
-
-                    cur_project_allocated += child_limit
-                # For -1, take any quota being eaten up by child, as well as
-                # what the child itself has given up to its children
-                else:
-                    child_in_use = child_quota[res_name].get('in_use', 0)
-                    # Recursively calculate child's allocated
-                    child_alloc = self._get_cur_project_allocated(
-                        ctxt, resource, {child_id: project_subtree[child_id]})
-                    cur_project_allocated += child_in_use + child_alloc
-
-            self._allocated[cur_project_id][res_name] = cur_project_allocated
-
-        return self._allocated[cur_project_id][res_name]
-
-    def get_default(self, context, resource, project_id):
-        """Get a specific default quota for a resource."""
-        resource = super(NestedDbQuotaDriver, self).get_default(
-            context, resource, project_id)
-
-        return 0 if quota_utils.get_parent_project_id(
-            context, project_id) else resource.default
-
-    def get_defaults(self, context, resources, project_id=None):
-        defaults = super(NestedDbQuotaDriver, self).get_defaults(
-            context, resources, project_id)
-        # All defaults are 0 for child project
-        if quota_utils.get_parent_project_id(context, project_id):
-            for key in defaults.keys():
-                defaults[key] = 0
-        return defaults
-
-    def _reserve(self, context, resources, quotas, deltas, expire, project_id):
-        reserved = []
-        # As to not change the exception behavior, flag every res that would
-        # be over instead of failing on first OverQuota
-        resources_failed_to_update = []
-        failed_usages = {}
-        for res in deltas.keys():
-            try:
-                reserved += db.quota_reserve(
-                    context, resources, quotas, {res: deltas[res]},
-                    expire, CONF.until_refresh, CONF.max_age, project_id)
-                if quotas[res] == -1:
-                    reserved += quota_utils.update_alloc_to_next_hard_limit(
-                        context, resources, deltas, res, expire, project_id)
-            except exception.OverQuota as e:
-                resources_failed_to_update.append(res)
-                failed_usages.update(e.kwargs['usages'])
-
-        if resources_failed_to_update:
-            db.reservation_rollback(context, reserved, project_id)
-            # We change OverQuota to OverVolumeLimit in other places and expect
-            # to find all of the OverQuota kwargs
-            raise exception.OverQuota(overs=sorted(resources_failed_to_update),
-                                      quotas=quotas, usages=failed_usages)
-
-        return reserved
-
-
 class BaseResource(object):
     """Describe a single resource for quota checking."""
 
@@ -843,10 +655,6 @@ class QuotaEngine(object):
         self._driver_class = self._quota_driver_class
         return self._driver_class
 
-    def using_nested_quotas(self):
-        """Returns true if nested quotas are being used"""
-        return isinstance(self._driver, NestedDbQuotaDriver)
-
     def __contains__(self, resource):
         return resource in self.resources
 
@@ -890,15 +698,16 @@ class QuotaEngine(object):
         return self._driver.get_default(context, resource,
                                         parent_project_id=parent_project_id)
 
-    def get_defaults(self, context, project_id=None):
+    def get_defaults(self, context, parent_project_id=None):
         """Retrieve the default quotas.
 
         :param context: The request context, for access checks.
-        :param project_id: The id of the current project
+        :param parent_project_id: The id of the current project's parent,
+                                  if any.
         """
 
         return self._driver.get_defaults(context, self.resources,
-                                         project_id)
+                                         parent_project_id=parent_project_id)
 
     def get_class_quotas(self, context, quota_class, defaults=True):
         """Retrieve the quotas for the given quota class.
@@ -915,7 +724,7 @@ class QuotaEngine(object):
                                              quota_class, defaults=defaults)
 
     def get_project_quotas(self, context, project_id, quota_class=None,
-                           defaults=True, usages=True):
+                           defaults=True, usages=True, parent_project_id=None):
         """Retrieve the quotas for the given project.
 
         :param context: The request context, for access checks.
@@ -927,14 +736,15 @@ class QuotaEngine(object):
                          default value, if there is no value from the
                          quota class) will be reported if there is no
                          specific value for the resource.
-        :param usages: If True, the current in_use, reserved and
-                       allocated counts will also be returned.
+        :param usages: If True, the current in_use and reserved counts
+                       will also be returned.
+        :param parent_project_id: The id of the current project's parent,
+                                  if any.
         """
-        return self._driver.get_project_quotas(context, self.resources,
-                                               project_id,
-                                               quota_class=quota_class,
-                                               defaults=defaults,
-                                               usages=usages)
+        return self._driver.get_project_quotas(
+            context, self.resources, project_id, quota_class=quota_class,
+            defaults=defaults, usages=usages,
+            parent_project_id=parent_project_id)
 
     def count(self, context, resource, *args, **kwargs):
         """Count a resource.
diff --git a/cinder/tests/functional/test_quotas.py b/cinder/tests/functional/test_quotas.py
deleted file mode 100644
index 85b230e1e..000000000
--- a/cinder/tests/functional/test_quotas.py
+++ /dev/null
@@ -1,170 +0,0 @@
-# All Rights Reserved.
-#
-#    Licensed under the Apache License, Version 2.0 (the "License"); you may
-#    not use this file except in compliance with the License. You may obtain
-#    a copy of the License at
-#
-#         http://www.apache.org/licenses/LICENSE-2.0
-#
-#    Unless required by applicable law or agreed to in writing, software
-#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
-#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
-#    License for the specific language governing permissions and limitations
-#    under the License.
-import mock
-import uuid
-
-from cinder import quota
-from cinder.tests import fake_driver
-from cinder.tests.functional.api import client
-from cinder.tests.functional import functional_helpers
-
-
-class NestedQuotasTest(functional_helpers._FunctionalTestBase):
-    _vol_type_name = 'functional_test_type'
-
-    def setUp(self):
-        super(NestedQuotasTest, self).setUp()
-        self.api.create_type(self._vol_type_name)
-        fake_driver.LoggingVolumeDriver.clear_logs()
-        self._create_project_hierarchy()
-        # Need to mock out Keystone so the functional tests don't require other
-        # services
-        _keystone_client = mock.MagicMock()
-        _keystone_client.version = 'v3'
-        _keystone_client.projects.get.side_effect = self._get_project
-        _keystone_client_get = mock.patch(
-            'cinder.quota_utils._keystone_client',
-            lambda *args, **kwargs: _keystone_client)
-        _keystone_client_get.start()
-        self.addCleanup(_keystone_client_get.stop)
-        # The QUOTA engine in Cinder is a global variable that lazy loads the
-        # quota driver, so even if we change the config for the quota driver,
-        # we won't reliably change the driver being used (or change it back)
-        # unless the global variables get cleaned up, so using mock instead to
-        # simulate this change
-        nested_driver = quota.NestedDbQuotaDriver()
-        _driver_patcher = mock.patch(
-            'cinder.quota.QuotaEngine._driver', new=nested_driver)
-        _driver_patcher.start()
-        self.addCleanup(_driver_patcher.stop)
-        # Default to using the top parent in the hierarchy
-        self._update_project(self.A.id)
-
-    def _get_flags(self):
-        f = super(NestedQuotasTest, self)._get_flags()
-        f['volume_driver'] = \
-            'cinder.tests.fake_driver.LoggingVolumeDriver'
-        f['default_volume_type'] = self._vol_type_name
-        return f
-
-    # Currently we use 413 error for over quota
-    over_quota_exception = client.OpenStackApiException413
-
-    def _create_project_hierarchy(self):
-        """Sets up the nested hierarchy show below.
-
-        +-----------+
-        |     A     |
-        |    / \    |
-        |   B   C   |
-        |  /        |
-        | D         |
-        +-----------+
-        """
-        self.A = self.FakeProject()
-        self.B = self.FakeProject(parent_id=self.A.id)
-        self.C = self.FakeProject(parent_id=self.A.id)
-        self.D = self.FakeProject(parent_id=self.B.id)
-
-        self.B.subtree = {self.D.id: self.D.subtree}
-        self.A.subtree = {self.B.id: self.B.subtree, self.C.id: self.C.subtree}
-
-        self.A.parents = None
-        self.B.parents = {self.A.id: None}
-        self.C.parents = {self.A.id: None}
-        self.D.parents = {self.B.id: self.B.parents}
-
-        # project_by_id attribute is used to recover a project based on its id.
-        self.project_by_id = {self.A.id: self.A, self.B.id: self.B,
-                              self.C.id: self.C, self.D.id: self.D}
-
-    class FakeProject(object):
-        _dom_id = uuid.uuid4().hex
-
-        def __init__(self, parent_id=None):
-            self.id = uuid.uuid4().hex
-            self.parent_id = parent_id
-            self.domain_id = self._dom_id
-            self.subtree = None
-            self.parents = None
-
-    def _get_project(self, project_id, *args, **kwargs):
-        return self.project_by_id[project_id]
-
-    def _create_volume(self):
-        return self.api.post_volume({'volume': {'size': 1}})
-
-    def test_default_quotas_enforced(self):
-        # Should be able to create volume on parent project by default
-        created_vol = self._create_volume()
-        self._poll_volume_while(created_vol['id'], ['creating'], 'available')
-        self._update_project(self.B.id)
-        # Shouldn't be able to create volume on child project by default
-        self.assertRaises(self.over_quota_exception, self._create_volume)
-
-    def test_update_child_with_parent_default_quota(self):
-        # Make sure we can update to a reasonable value
-        self.api.quota_set(self.B.id, {'volumes': 5})
-        # Ensure that the update took and we can create a volume
-        self._poll_volume_while(
-            self._create_volume()['id'], ['creating'], 'available')
-
-    def test_quota_update_child_greater_than_parent(self):
-        self.assertRaises(
-            client.OpenStackApiException400,
-            self.api.quota_set, self.B.id, {'volumes': 11})
-
-    def test_child_soft_limit_propagates_to_parent(self):
-        self.api.quota_set(self.B.id, {'volumes': 0})
-        self.api.quota_set(self.D.id, {'volumes': -1})
-        self._update_project(self.D.id)
-        self.assertRaises(self.over_quota_exception, self._create_volume)
-
-    def test_child_quota_hard_limits_affects_parents_allocated(self):
-        self.api.quota_set(self.B.id, {'volumes': 5})
-        self.api.quota_set(self.C.id, {'volumes': 3})
-        alloc = self.api.quota_get(self.A.id)['volumes']['allocated']
-        self.assertEqual(8, alloc)
-        self.assertRaises(client.OpenStackApiException400,
-                          self.api.quota_set, self.C.id, {'volumes': 6})
-
-    def _update_quota_and_def_type(self, project_id, quota):
-        self.api.quota_set(project_id, quota)
-        type_updates = {'%s_%s' % (key, self._vol_type_name): val for key, val
-                        in quota.items() if key != 'per_volume_gigabytes'}
-        return self.api.quota_set(project_id, type_updates)
-
-    def test_grandchild_soft_limit_propogates_up(self):
-        quota = {'volumes': -1, 'gigabytes': -1, 'per_volume_gigabytes': -1}
-        self._update_quota_and_def_type(self.B.id, quota)
-        self._update_quota_and_def_type(self.D.id, quota)
-        self._update_project(self.D.id)
-        # Create two volumes in the grandchild project and ensure grandparent's
-        # allocated is updated accordingly
-        vol = self._create_volume()
-        self._create_volume()
-        self._update_project(self.A.id)
-        alloc = self.api.quota_get(self.A.id)['volumes']['allocated']
-        self.assertEqual(2, alloc)
-        alloc = self.api.quota_get(self.B.id)['volumes']['allocated']
-        self.assertEqual(2, alloc)
-        # Ensure delete reduces the quota
-        self._update_project(self.D.id)
-        self.api.delete_volume(vol['id'])
-        self._poll_volume_while(vol['id'], ['deleting'])
-        self._update_project(self.A.id)
-        alloc = self.api.quota_get(self.A.id)['volumes']['allocated']
-        self.assertEqual(1, alloc)
-        alloc = self.api.quota_get(self.B.id)['volumes']['allocated']
-        self.assertEqual(1, alloc)
diff --git a/cinder/tests/unit/api/contrib/test_identity.py b/cinder/tests/unit/api/contrib/test_identity.py
new file mode 100644
index 000000000..69d102a9d
--- /dev/null
+++ b/cinder/tests/unit/api/contrib/test_identity.py
@@ -0,0 +1,90 @@
+# Copyright 2017 IBM Corp.
+# All Rights Reserved.
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+
+import mock
+
+from keystoneauth1 import exceptions as kse
+from oslo_serialization import jsonutils
+import webob
+
+from cinder.api.contrib import identity
+from cinder import test
+
+
+class FakeResponse(object):
+    """A basic response constainer that simulates requests.Response.
+
+    One of the critical things is that a success error code makes the
+    object return true.
+
+    """
+    def __init__(self, status_code, content=""):
+        self.status_code = status_code
+        self.content = content
+
+    def json(self):
+        return {'project': jsonutils.loads(self.content)}
+
+
+class IdentityValidationTest(test.TestCase):
+
+    @mock.patch('keystoneauth1.session.Session.get')
+    def test_good_id(self, get):
+        get.return_value = FakeResponse(200, '{}')
+        self.assertEqual({}, identity.get_project(mock.MagicMock(), 'foo'))
+        get.assert_called_once_with(
+            '/projects/foo',
+            endpoint_filter={'service_type': 'identity'},
+            raise_exc=False)
+
+    @mock.patch('keystoneauth1.session.Session.get')
+    def test_no_project(self, get):
+        get.return_value = FakeResponse(404)
+        self.assertRaises(webob.exc.HTTPBadRequest,
+                          identity.get_project,
+                          mock.MagicMock(), "foo")
+        get.assert_called_once_with(
+            '/projects/foo',
+            endpoint_filter={'service_type': 'identity'},
+            raise_exc=False)
+
+    @mock.patch('keystoneauth1.session.Session.get')
+    def test_unknown_id(self, get):
+        get.return_value = FakeResponse(403)
+        self.assertRaises(webob.exc.HTTPBadRequest,
+                          identity.get_project,
+                          mock.MagicMock(), "foo")
+        get.assert_called_once_with(
+            '/projects/foo',
+            endpoint_filter={'service_type': 'identity'},
+            raise_exc=False)
+
+    @mock.patch('keystoneauth1.session.Session.get')
+    def test_unknown_error(self, get):
+        get.return_value = FakeResponse(500, "Oh noes!")
+        self.assertRaises(webob.exc.HTTPBadRequest,
+                          identity.get_project,
+                          mock.MagicMock(), "foo")
+        get.assert_called_once_with(
+            '/projects/foo',
+            endpoint_filter={'service_type': 'identity'},
+            raise_exc=False)
+
+    @mock.patch('keystoneauth1.session.Session.get')
+    def test_early_fail(self, get):
+        get.side_effect = kse.EndpointNotFound()
+        self.assertRaises(webob.exc.HTTPBadRequest,
+                          identity.get_project,
+                          mock.MagicMock(), "foo")
diff --git a/cinder/tests/unit/api/contrib/test_quotas.py b/cinder/tests/unit/api/contrib/test_quotas.py
index 602938a1e..4d029b698 100644
--- a/cinder/tests/unit/api/contrib/test_quotas.py
+++ b/cinder/tests/unit/api/contrib/test_quotas.py
@@ -28,14 +28,12 @@ from cinder.api.contrib import quotas
 from cinder import context
 from cinder import db
 from cinder import exception
-from cinder import quota
 from cinder import test
 from cinder.tests.unit import fake_constants as fake
 from cinder.tests.unit import test_db_api
 
 
 from oslo_config import cfg
-from oslo_config import fixture as config_fixture
 
 
 CONF = cfg.CONF
@@ -67,26 +65,20 @@ def make_body(root=True, gigabytes=1000, snapshots=10,
     return result
 
 
-def make_subproject_body(root=True, gigabytes=0, snapshots=0,
-                         volumes=0, backups=0, backup_gigabytes=0,
-                         tenant_id=fake.PROJECT_ID, per_volume_gigabytes=0):
+def make_subproject_body(root=True, gigabytes=1000, snapshots=10,
+                         volumes=10, backups=0, backup_gigabytes=0,
+                         tenant_id=fake.PROJECT_ID, per_volume_gigabytes=-1):
     return make_body(root=root, gigabytes=gigabytes, snapshots=snapshots,
                      volumes=volumes, backups=backups,
                      backup_gigabytes=backup_gigabytes, tenant_id=tenant_id,
                      per_volume_gigabytes=per_volume_gigabytes)
 
 
-class QuotaSetsControllerTestBase(test.TestCase):
+def raise_forbidden(*_):
+    raise webob.exc.HTTPForbidden
 
-    class FakeProject(object):
 
-        def __init__(self, id=fake.PROJECT_ID, parent_id=None,
-                     is_admin_project=False):
-            self.id = id
-            self.parent_id = parent_id
-            self.subtree = None
-            self.parents = None
-            self.is_admin_project = is_admin_project
+class QuotaSetsControllerTestBase(test.TestCase):
 
     def setUp(self):
         super(QuotaSetsControllerTestBase, self).setUp()
@@ -96,70 +88,17 @@ class QuotaSetsControllerTestBase(test.TestCase):
         self.req = mock.Mock()
         self.req.environ = {'cinder.context': context.get_admin_context()}
         self.req.environ['cinder.context'].is_admin = True
-        self.req.params = {}
-
-        self._create_project_hierarchy()
-        self.req.environ['cinder.context'].project_id = self.A.id
-
-        get_patcher = mock.patch('cinder.quota_utils.get_project_hierarchy',
-                                 self._get_project)
-        get_patcher.start()
-        self.addCleanup(get_patcher.stop)
-
-        def _list_projects(context):
-            return self.project_by_id.values()
-
-        list_patcher = mock.patch('cinder.quota_utils.get_all_projects',
-                                  _list_projects)
-        list_patcher.start()
-        self.addCleanup(list_patcher.stop)
-
-        self.auth_url = 'http://localhost:5000'
-        self.fixture = self.useFixture(config_fixture.Config(CONF))
-        self.fixture.config(auth_uri=self.auth_url, group='keystone_authtoken')
-
-    def _create_project_hierarchy(self):
-        """Sets an environment used for nested quotas tests.
-
-        Create a project hierarchy such as follows:
-        +-----------+
-        |           |
-        |     A     |
-        |    / \    |
-        |   B   C   |
-        |  /        |
-        | D         |
-        +-----------+
-        """
-        self.A = self.FakeProject(id=uuid.uuid4().hex, parent_id=None)
-        self.B = self.FakeProject(id=uuid.uuid4().hex, parent_id=self.A.id)
-        self.C = self.FakeProject(id=uuid.uuid4().hex, parent_id=self.A.id)
-        self.D = self.FakeProject(id=uuid.uuid4().hex, parent_id=self.B.id)
-
-        # update projects subtrees
-        self.B.subtree = {self.D.id: self.D.subtree}
-        self.A.subtree = {self.B.id: self.B.subtree, self.C.id: self.C.subtree}
-
-        self.A.parents = None
-        self.B.parents = {self.A.id: None}
-        self.C.parents = {self.A.id: None}
-        self.D.parents = {self.B.id: self.B.parents}
-
-        # project_by_id attribute is used to recover a project based on its id.
-        self.project_by_id = {self.A.id: self.A, self.B.id: self.B,
-                              self.C.id: self.C, self.D.id: self.D}
-
-    def _get_project(self, context, id, subtree_as_ids=False,
-                     parents_as_ids=False, is_admin_project=False):
-        return self.project_by_id.get(id, self.FakeProject())
+        self.req.environ['cinder.context'].auth_token = uuid.uuid4().hex
+        self.req.environ['cinder.context'].project_id = fake.PROJECT_ID
 
-    def _create_fake_quota_usages(self, usage_map):
-        self._fake_quota_usages = {}
-        for key, val in usage_map.items():
-            self._fake_quota_usages[key] = {'in_use': val}
+        keystone = mock.patch(
+            'cinder.api.contrib.identity.get_project',
+            side_effect=self.get_project_by_id
+        ).start()
+        self.addCleanup(keystone.stop)
 
-    def _fake_quota_usage_get_all_by_project(self, context, project_id):
-        return {'volumes': self._fake_quota_usages[project_id]}
+    def get_project_by_id(self, context, project_id):
+        return {'id': project_id, 'parent_id': None}
 
 
 class QuotaSetsControllerTest(QuotaSetsControllerTestBase):
@@ -168,26 +107,27 @@ class QuotaSetsControllerTest(QuotaSetsControllerTestBase):
 
     def test_defaults(self):
         result = self.controller.defaults(self.req, fake.PROJECT_ID)
-        self.assertDictMatch(make_body(), result)
+        self.assertEqual(make_body(), result)
 
     def test_show(self):
         result = self.controller.show(self.req, fake.PROJECT_ID)
-        self.assertDictMatch(make_body(), result)
+        self.assertEqual(make_body(), result)
 
     def test_show_not_authorized(self):
-        self.req.environ['cinder.context'].is_admin = False
+        self.req.environ['cinder.context'].can = raise_forbidden
         self.req.environ['cinder.context'].user_id = fake.USER_ID
         self.req.environ['cinder.context'].project_id = fake.PROJECT_ID
         self.assertRaises(webob.exc.HTTPForbidden, self.controller.show,
                           self.req, fake.PROJECT2_ID)
 
     def test_show_non_admin_user(self):
-        self.controller._get_quotas = mock.Mock(side_effect=
-                                                self.controller._get_quotas)
+        self.controller._get_quotas = mock.Mock(
+            side_effect=self.controller._get_quotas)
         result = self.controller.show(self.req, fake.PROJECT_ID)
-        self.assertDictMatch(make_body(), result)
+        self.assertEqual(make_body(), result)
         self.controller._get_quotas.assert_called_with(
-            self.req.environ['cinder.context'], fake.PROJECT_ID, False)
+            self.req.environ['cinder.context'], fake.PROJECT_ID, False,
+            parent_project_id=None)
 
     def test_show_with_invalid_usage_param(self):
         self.req.params = {'usage': 'InvalidBool'}
@@ -198,40 +138,18 @@ class QuotaSetsControllerTest(QuotaSetsControllerTestBase):
     def test_show_with_valid_usage_param(self):
         self.req.params = {'usage': 'false'}
         result = self.controller.show(self.req, fake.PROJECT_ID)
-        self.assertDictMatch(make_body(), result)
+        self.assertEqual(make_body(), result)
 
     def test_update(self):
         body = make_body(gigabytes=2000, snapshots=15,
                          volumes=5, backups=5, tenant_id=None)
         result = self.controller.update(self.req, fake.PROJECT_ID, body)
-        self.assertDictMatch(body, result)
+        self.assertEqual(body, result)
 
         body = make_body(gigabytes=db.MAX_INT, tenant_id=None)
         result = self.controller.update(self.req, fake.PROJECT_ID, body)
-        self.assertDictMatch(body, result)
-
-    def test_update_subproject_not_in_hierarchy_non_nested(self):
-        # When not using nested quotas, the hierarchy should not be considered
-        # for an update
-        E = self.FakeProject(id=uuid.uuid4().hex, parent_id=None)
-        F = self.FakeProject(id=uuid.uuid4().hex, parent_id=E.id)
-        E.subtree = {F.id: F.subtree}
-        self.project_by_id[E.id] = E
-        self.project_by_id[F.id] = F
+        self.assertEqual(body, result)
 
-        # Update the project A quota.
-        self.req.environ['cinder.context'].project_id = self.A.id
-        body = make_body(gigabytes=2000, snapshots=15,
-                         volumes=5, backups=5, tenant_id=None)
-        result = self.controller.update(self.req, self.A.id, body)
-        self.assertDictMatch(body, result)
-        # Try to update the quota of F, it will be allowed even though
-        # project E doesn't belong to the project hierarchy of A, because
-        # we are NOT using the nested quota driver
-        self.req.environ['cinder.context'].project_id = self.A.id
-        body = make_body(gigabytes=2000, snapshots=15,
-                         volumes=5, backups=5, tenant_id=None)
-        self.controller.update(self.req, F.id, body)
 
     @mock.patch(
         'cinder.api.openstack.wsgi.Controller.validate_string_length')
@@ -270,7 +188,7 @@ class QuotaSetsControllerTest(QuotaSetsControllerTestBase):
                           self.req, fake.PROJECT_ID, body)
         # Verify that quota values are not updated in db
         new_quota = self.controller.show(self.req, fake.PROJECT_ID)
-        self.assertDictMatch(orig_quota, new_quota)
+        self.assertEqual(orig_quota, new_quota)
 
     def test_update_bad_quota_limit(self):
         body = {'quota_set': {'gigabytes': -1000}}
@@ -339,746 +257,130 @@ class QuotaSetsControllerTest(QuotaSetsControllerTestBase):
 
     def test_delete(self):
         result_show = self.controller.show(self.req, fake.PROJECT_ID)
-        self.assertDictMatch(make_body(), result_show)
+        self.assertEqual(make_body(), result_show)
 
         body = make_body(gigabytes=2000, snapshots=15,
                          volumes=5, backups=5,
                          backup_gigabytes=1000, tenant_id=None)
         result_update = self.controller.update(self.req, fake.PROJECT_ID, body)
-        self.assertDictMatch(body, result_update)
+        self.assertEqual(body, result_update)
 
         self.controller.delete(self.req, fake.PROJECT_ID)
 
         result_show_after = self.controller.show(self.req, fake.PROJECT_ID)
-        self.assertDictMatch(result_show, result_show_after)
-
-    def test_delete_with_allocated_quota_different_from_zero(self):
-        self.req.environ['cinder.context'].project_id = self.A.id
-
-        body = make_body(gigabytes=2000, snapshots=15,
-                         volumes=5, backups=5,
-                         backup_gigabytes=1000, tenant_id=None)
-        result_update = self.controller.update(self.req, self.A.id, body)
-        self.assertDictMatch(body, result_update)
-
-        # Set usage param to True in order to see get allocated values.
-        self.req.params = {'usage': 'True'}
-        result_show = self.controller.show(self.req, self.A.id)
-
-        result_update = self.controller.update(self.req, self.B.id, body)
-        self.assertDictMatch(body, result_update)
-
-        self.controller.delete(self.req, self.B.id)
-
-        result_show_after = self.controller.show(self.req, self.A.id)
-        self.assertDictMatch(result_show, result_show_after)
-
-    def test_delete_no_admin(self):
-        self.req.environ['cinder.context'].is_admin = False
-        self.assertRaises(webob.exc.HTTPForbidden, self.controller.delete,
-                          self.req, fake.PROJECT_ID)
+        self.assertEqual(result_show, result_show_after)
 
-    def test_subproject_show_not_using_nested_quotas(self):
-        # Current roles say for non-nested quotas, an admin should be able to
-        # see anyones quota
-        self.req.environ['cinder.context'].project_id = self.B.id
-        self.controller.show(self.req, self.C.id)
-        self.controller.show(self.req, self.A.id)
 
-
-class QuotaSetControllerValidateNestedQuotaSetup(QuotaSetsControllerTestBase):
-    """Validates the setup before using NestedQuota driver.
-
-    Test case validates flipping on NestedQuota driver after using the
-    non-nested quota driver for some time.
-    """
+class HierarchicalQuotasTestV21(QuotaSetsControllerTestBase):
+    def setUp(self):
+        super(HierarchicalQuotasTestV21, self).setUp()
+        self._create_project_hierarchy()
 
     def _create_project_hierarchy(self):
         """Sets an environment used for nested quotas tests.
-
         Create a project hierarchy such as follows:
-        +-----------------+
-        |                 |
-        |     A    G   E  |
-        |    / \       \  |
-        |   B   C       F |
-        |  /              |
-        | D               |
-        +-----------------+
+        +-----------+
+        |           |
+        |     A     |
+        |    / \    |
+        |   B   C   |
+        |  /        |
+        | D         |
+        +-----------+
         """
-        super(QuotaSetControllerValidateNestedQuotaSetup,
-              self)._create_project_hierarchy()
-        # Project A, B, C, D are already defined by parent test class
-        self.E = self.FakeProject(id=uuid.uuid4().hex, parent_id=None)
-        self.F = self.FakeProject(id=uuid.uuid4().hex, parent_id=self.E.id)
-        self.G = self.FakeProject(id=uuid.uuid4().hex, parent_id=None)
-
-        self.E.subtree = {self.F.id: self.F.subtree}
-
-        self.project_by_id.update({self.E.id: self.E, self.F.id: self.F,
-                                   self.G.id: self.G})
-
-    def test_validate_nested_quotas_no_in_use_vols(self):
-        # Update the project A quota.
-        self.req.environ['cinder.context'].project_id = self.A.id
-        quota = {'volumes': 5}
-        body = {'quota_set': quota}
-        self.controller.update(self.req, self.A.id, body)
-
-        quota['volumes'] = 3
-        self.controller.update(self.req, self.B.id, body)
-        # Allocated value for quota A is borked, because update was done
-        # without nested quota driver
-        self.assertRaises(webob.exc.HTTPBadRequest,
-                          self.controller.validate_setup_for_nested_quota_use,
-                          self.req)
-
-        # Fix the allocated values in DB
-        self.req.params['fix_allocated_quotas'] = True
-        self.controller.validate_setup_for_nested_quota_use(
-            self.req)
-
-        self.req.params['fix_allocated_quotas'] = False
-        # Ensure that we've properly fixed the allocated quotas
-        self.controller.validate_setup_for_nested_quota_use(self.req)
-
-        # Over-allocate the quotas between children
-        self.controller.update(self.req, self.C.id, body)
-
-        # This is we should fail because the child limits are too big
-        self.assertRaises(webob.exc.HTTPBadRequest,
-                          self.controller.validate_setup_for_nested_quota_use,
-                          self.req)
-
-        quota['volumes'] = 1
-        self.controller.update(self.req, self.C.id, body)
-
-        # Make sure we're validating all hierarchy trees
-        self.req.environ['cinder.context'].project_id = self.E.id
-        quota['volumes'] = 1
-        self.controller.update(self.req, self.E.id, body)
-        quota['volumes'] = 3
-        self.controller.update(self.req, self.F.id, body)
-
-        self.assertRaises(
-            webob.exc.HTTPBadRequest,
-            self.controller.validate_setup_for_nested_quota_use,
-            self.req)
-
-        # Put quotas in a good state
-        quota['volumes'] = 1
-        self.controller.update(self.req, self.F.id, body)
-        self.req.params['fix_allocated_quotas'] = True
-        self.controller.validate_setup_for_nested_quota_use(self.req)
-
-    @mock.patch('cinder.db.quota_usage_get_all_by_project')
-    def test_validate_nested_quotas_in_use_vols(self, mock_usage):
-        self._create_fake_quota_usages(
-            {self.A.id: 1, self.B.id: 1, self.D.id: 0, self.C.id: 3,
-             self.E.id: 0, self.F.id: 0, self.G.id: 0})
-        mock_usage.side_effect = self._fake_quota_usage_get_all_by_project
-
-        # Update the project A quota.
-        self.req.environ['cinder.context'].project_id = self.A.id
-        quota_limit = {'volumes': 7}
-        body = {'quota_set': quota_limit}
-        self.controller.update(self.req, self.A.id, body)
-
-        quota_limit['volumes'] = 3
-        self.controller.update(self.req, self.B.id, body)
-
-        quota_limit['volumes'] = 3
-        self.controller.update(self.req, self.C.id, body)
-
-        self.req.params['fix_allocated_quotas'] = True
-        self.controller.validate_setup_for_nested_quota_use(self.req)
-
-        quota_limit['volumes'] = 6
-        self.controller.update(self.req, self.A.id, body)
-
-        # Should fail because the one in_use volume of 'A'
-        self.assertRaises(
-            webob.exc.HTTPBadRequest,
-            self.controller.validate_setup_for_nested_quota_use,
-            self.req)
-
-    @mock.patch('cinder.db.quota_usage_get_all_by_project')
-    def test_validate_nested_quotas_quota_borked(self, mock_usage):
-        self._create_fake_quota_usages(
-            {self.A.id: 1, self.B.id: 1, self.D.id: 0, self.C.id: 3,
-             self.E.id: 0, self.F.id: 0, self.G.id: 0})
-        mock_usage.side_effect = self._fake_quota_usage_get_all_by_project
-
-        # Update the project A quota.
-        self.req.environ['cinder.context'].project_id = self.A.id
-        quota_limit = {'volumes': 7}
-        body = {'quota_set': quota_limit}
-        self.controller.update(self.req, self.A.id, body)
-
-        # Other quotas would default to 0 but already have some limit being
-        # used
-        self.assertRaises(
-            webob.exc.HTTPBadRequest,
-            self.controller.validate_setup_for_nested_quota_use,
-            self.req)
-
-    @mock.patch('cinder.db.quota_usage_get_all_by_project')
-    def test_validate_nested_quota_negative_limits(self, mock_usage):
-        # TODO(mc_nair): this test case can be moved to Tempest once nested
-        # quota coverage added
-        self._create_fake_quota_usages(
-            {self.A.id: 1, self.B.id: 3, self.C.id: 0, self.D.id: 2,
-             self.E.id: 2, self.F.id: 0, self.G.id: 0})
-        mock_usage.side_effect = self._fake_quota_usage_get_all_by_project
-
-        # Setting E-F as children of D for this test case to flex the muscles
-        # of more complex nesting
-        self.D.subtree = {self.E.id: self.E.subtree}
-        self.E.parent_id = self.D.id
-        # Get B's subtree up to date with this change
-        self.B.subtree[self.D.id] = self.D.subtree
-
-        # Quota hierarchy now is
-        #   / B - D - E - F
-        # A
-        #   \ C
-        #
-        # G
-
-        self.req.environ['cinder.context'].project_id = self.A.id
-        quota_limit = {'volumes': 10}
-        body = {'quota_set': quota_limit}
-        self.controller.update(self.req, self.A.id, body)
-
-        quota_limit['volumes'] = 1
-        self.controller.update(self.req, self.C.id, body)
-
-        quota_limit['volumes'] = -1
-        self.controller.update(self.req, self.B.id, body)
-        self.controller.update(self.req, self.D.id, body)
-        self.controller.update(self.req, self.F.id, body)
-        quota_limit['volumes'] = 5
-        self.controller.update(self.req, self.E.id, body)
-
-        # Should fail because too much is allocated to children for A
-        self.assertRaises(webob.exc.HTTPBadRequest,
-                          self.controller.validate_setup_for_nested_quota_use,
-                          self.req)
-
-        # When root has -1 limit, children can allocate as much as they want
-        quota_limit['volumes'] = -1
-        self.controller.update(self.req, self.A.id, body)
-        self.req.params['fix_allocated_quotas'] = True
-        self.controller.validate_setup_for_nested_quota_use(self.req)
-
-        # Not unlimited, but make children's allocated within bounds
-        quota_limit['volumes'] = 10
-        self.controller.update(self.req, self.A.id, body)
-        quota_limit['volumes'] = 3
-        self.controller.update(self.req, self.E.id, body)
-        self.req.params['fix_allocated_quotas'] = True
-        self.controller.validate_setup_for_nested_quota_use(self.req)
-        self.req.params['fix_allocated_quotas'] = False
-        self.controller.validate_setup_for_nested_quota_use(self.req)
-
-
-class QuotaSetsControllerNestedQuotasTest(QuotaSetsControllerTestBase):
-    def setUp(self):
-        super(QuotaSetsControllerNestedQuotasTest, self).setUp()
-        driver = quota.NestedDbQuotaDriver()
-        patcher = mock.patch('cinder.quota.VolumeTypeQuotaEngine._driver',
-                             driver)
-        patcher.start()
-        self.addCleanup(patcher.stop)
+        self.project_a = {'id': 'project_a', 'parent_id': None}
+        self.project_b = {'id': 'project_b', 'parent_id': self.project_a['id']}
+        self.project_c = {'id': 'project_c', 'parent_id': self.project_a['id']}
+        self.project_d = {'id': 'project_d', 'parent_id': self.project_b['id']}
+        # project_by_id attribute is used to recover a project based on its id.
+        self.project_by_id = {
+            self.project_a['id']: self.project_a,
+            self.project_b['id']: self.project_b,
+            self.project_c['id']: self.project_c,
+            self.project_d['id']: self.project_d,
+        }
+
+    def get_project_by_id(self, ctx, project_id):
+        if project_id in self.project_by_id:
+            return self.project_by_id[project_id]
+        return super(HierarchicalQuotasTestV21, self).get_project_by_id(
+            context, project_id)
 
     def test_subproject_defaults(self):
         context = self.req.environ['cinder.context']
-        context.project_id = self.B.id
-        result = self.controller.defaults(self.req, self.B.id)
-        expected = make_subproject_body(tenant_id=self.B.id)
-        self.assertDictMatch(expected, result)
+        context.project_id = self.project_b['id']
+        result = self.controller.defaults(self.req, self.project_b['id'])
+        expected = make_subproject_body(
+            tenant_id=self.project_b['id'], per_volume_gigabytes=-1)
+        self.assertEqual(expected, result)
 
     def test_subproject_show(self):
-        self.req.environ['cinder.context'].project_id = self.A.id
-        result = self.controller.show(self.req, self.B.id)
-        expected = make_subproject_body(tenant_id=self.B.id)
-        self.assertDictMatch(expected, result)
+        self.req.environ['cinder.context'].project_id = self.project_a['id']
+        result = self.controller.show(self.req, self.project_b['id'])
+        expected = make_subproject_body(
+            tenant_id=self.project_b['id'], per_volume_gigabytes=-1)
+        self.assertEqual(expected, result)
 
     def test_subproject_show_in_hierarchy(self):
-        # A user scoped to a root project in a hierarchy can see its children
-        # quotas.
-        self.req.environ['cinder.context'].project_id = self.A.id
-        result = self.controller.show(self.req, self.D.id)
-        expected = make_subproject_body(tenant_id=self.D.id)
-        self.assertDictMatch(expected, result)
-        # A user scoped to a parent project can see its immediate children
-        # quotas.
-        self.req.environ['cinder.context'].project_id = self.B.id
-        result = self.controller.show(self.req, self.D.id)
-        expected = make_subproject_body(tenant_id=self.D.id)
-        self.assertDictMatch(expected, result)
-
-    def test_subproject_show_not_in_hierarchy_admin_context(self):
-        E = self.FakeProject(id=uuid.uuid4().hex, parent_id=None,
-                             is_admin_project=True)
-        self.project_by_id[E.id] = E
-        self.req.environ['cinder.context'].project_id = E.id
-        result = self.controller.show(self.req, self.B.id)
-        expected = make_subproject_body(tenant_id=self.B.id)
-        self.assertDictMatch(expected, result)
-
-    def test_subproject_show_target_project_equals_to_context_project(
-            self):
-        self.req.environ['cinder.context'].project_id = self.B.id
-        result = self.controller.show(self.req, self.B.id)
-        expected = make_subproject_body(tenant_id=self.B.id)
-        self.assertDictMatch(expected, result)
-
-    def test_subproject_show_not_authorized(self):
-        self.req.environ['cinder.context'].project_id = self.B.id
-        self.assertRaises(webob.exc.HTTPForbidden, self.controller.show,
-                          self.req, self.C.id)
-        self.req.environ['cinder.context'].project_id = self.B.id
-        self.assertRaises(webob.exc.HTTPForbidden, self.controller.show,
-                          self.req, self.A.id)
-
-    def test_update_subproject_not_in_hierarchy(self):
-        # Create another project hierarchy
-        E = self.FakeProject(id=uuid.uuid4().hex, parent_id=None)
-        F = self.FakeProject(id=uuid.uuid4().hex, parent_id=E.id)
-        E.subtree = {F.id: F.subtree}
-        self.project_by_id[E.id] = E
-        self.project_by_id[F.id] = F
-
-        # Update the project A quota.
-        self.req.environ['cinder.context'].project_id = self.A.id
-        body = make_body(gigabytes=2000, snapshots=15,
-                         volumes=5, backups=5, tenant_id=None)
-        result = self.controller.update(self.req, self.A.id, body)
-        self.assertDictMatch(body, result)
-        # Try to update the quota of F, it will not be allowed, since the
-        # project E doesn't belongs to the project hierarchy of A.
-        self.req.environ['cinder.context'].project_id = self.A.id
-        body = make_body(gigabytes=2000, snapshots=15,
-                         volumes=5, backups=5, tenant_id=None)
-        self.assertRaises(webob.exc.HTTPForbidden,
-                          self.controller.update, self.req, F.id, body)
-
-    def test_update_subproject_not_in_hierarchy_admin_context(self):
-        E = self.FakeProject(id=uuid.uuid4().hex, parent_id=None,
-                             is_admin_project=True)
-        self.project_by_id[E.id] = E
-        self.req.environ['cinder.context'].project_id = E.id
-        body = make_body(gigabytes=2000, snapshots=15,
-                         volumes=5, backups=5, tenant_id=None)
-        # Update the project A quota, not in the project hierarchy
-        # of E but it will be allowed because E is the cloud admin.
-        result = self.controller.update(self.req, self.A.id, body)
-        self.assertDictMatch(body, result)
-        # Update the quota of B to be equal to its parent A.
-        result = self.controller.update(self.req, self.B.id, body)
-        self.assertDictMatch(body, result)
-        # Remove the admin role from project E
-        E.is_admin_project = False
-        # Now updating the quota of B will fail, because it is not
-        # a member of E's hierarchy and E is no longer a cloud admin.
-        self.assertRaises(webob.exc.HTTPForbidden,
-                          self.controller.update, self.req, self.B.id, body)
+        result = self.controller.show(self.req, self.project_d['id'])
+        expected = make_subproject_body(tenant_id=self.project_d['id'])
+        self.assertEqual(expected, result)
+        result = self.controller.show(self.req, self.project_d['id'])
+        expected = make_subproject_body(
+            tenant_id=self.project_d['id'], per_volume_gigabytes=-1)
+        self.assertEqual(expected, result)
+
+    def test_subproject_show_target_project_equals_to_context_project(self):
+        result = self.controller.show(self.req, self.project_b['id'])
+        expected = make_subproject_body(
+            tenant_id=self.project_b['id'], per_volume_gigabytes=-1)
+        self.assertEqual(expected, result)
 
     def test_update_subproject(self):
         # Update the project A quota.
-        self.req.environ['cinder.context'].project_id = self.A.id
+        body = make_body(
+            gigabytes=2000, snapshots=15, volumes=5, backups=5, tenant_id=None)
+        result = self.controller.update(self.req, self.project_a['id'], body)
+        self.assertEqual(body, result)
         body = make_body(gigabytes=2000, snapshots=15,
                          volumes=5, backups=5, tenant_id=None)
-        result = self.controller.update(self.req, self.A.id, body)
-        self.assertDictMatch(body, result)
-        # Update the quota of B to be equal to its parent quota
-        self.req.environ['cinder.context'].project_id = self.A.id
-        body = make_body(gigabytes=2000, snapshots=15,
-                         volumes=5, backups=5, tenant_id=None)
-        result = self.controller.update(self.req, self.B.id, body)
-        self.assertDictMatch(body, result)
+        result = self.controller.update(self.req, self.project_b['id'], body)
+        self.assertEqual(body, result)
         # Try to update the quota of C, it will not be allowed, since the
         # project A doesn't have free quota available.
-        self.req.environ['cinder.context'].project_id = self.A.id
         body = make_body(gigabytes=2000, snapshots=15,
                          volumes=5, backups=5, tenant_id=None)
         self.assertRaises(webob.exc.HTTPBadRequest, self.controller.update,
-                          self.req, self.C.id, body)
-        # Successfully update the quota of D.
-        self.req.environ['cinder.context'].project_id = self.A.id
+                          self.req, self.project_c['id'], body)
         body = make_body(gigabytes=1000, snapshots=7,
                          volumes=3, backups=3, tenant_id=None)
-        result = self.controller.update(self.req, self.D.id, body)
-        self.assertDictMatch(body, result)
-        # An admin of B can also update the quota of D, since D is its
+        result = self.controller.update(self.req, self.project_d['id'], body)
+        self.assertEqual(body, result)
+        # An admin of B can also update the quota of D, since D is its an
         # immediate child.
-        self.req.environ['cinder.context'].project_id = self.B.id
         body = make_body(gigabytes=1500, snapshots=10,
                          volumes=4, backups=4, tenant_id=None)
-        self.controller.update(self.req, self.D.id, body)
-
-    def test_update_subproject_repetitive(self):
-        # Update the project A volumes quota.
-        self.req.environ['cinder.context'].project_id = self.A.id
-        body = make_body(gigabytes=2000, snapshots=15,
-                         volumes=10, backups=5, tenant_id=None)
-        result = self.controller.update(self.req, self.A.id, body)
-        self.assertDictMatch(body, result)
-        # Update the quota of B to be equal to its parent quota
-        # three times should be successful, the quota will not be
-        # allocated to 'allocated' value of parent project
-        for i in range(0, 3):
-            self.req.environ['cinder.context'].project_id = self.A.id
-            body = make_body(gigabytes=2000, snapshots=15,
-                             volumes=10, backups=5, tenant_id=None)
-            result = self.controller.update(self.req, self.B.id, body)
-            self.assertDictMatch(body, result)
-
-    def test_update_subproject_with_not_root_context_project(self):
-        # Update the project A quota.
-        self.req.environ['cinder.context'].project_id = self.A.id
-        body = make_body(gigabytes=2000, snapshots=15,
-                         volumes=5, backups=5, tenant_id=None)
-        result = self.controller.update(self.req, self.A.id, body)
-        self.assertDictMatch(body, result)
-        # Try to update the quota of B, it will not be allowed, since the
-        # project in the context (B) is not a root project.
-        self.req.environ['cinder.context'].project_id = self.B.id
-        body = make_body(gigabytes=2000, snapshots=15,
-                         volumes=5, backups=5, tenant_id=None)
-        self.assertRaises(webob.exc.HTTPForbidden, self.controller.update,
-                          self.req, self.B.id, body)
-
-    def test_update_subproject_quota_when_parent_has_default_quotas(self):
-        # Since the quotas of the project A were not updated, it will have
-        # default quotas.
-        self.req.environ['cinder.context'].project_id = self.A.id
-        # Update the project B quota.
-        expected = make_body(gigabytes=1000, snapshots=10,
-                             volumes=5, backups=5, tenant_id=None)
-        result = self.controller.update(self.req, self.B.id, expected)
-        self.assertDictMatch(expected, result)
-
-    def _assert_quota_show(self, proj_id, resource, in_use=0, reserved=0,
-                           allocated=0, limit=0):
-        self.req.params = {'usage': 'True'}
-        show_res = self.controller.show(self.req, proj_id)
-        expected = {'in_use': in_use, 'reserved': reserved,
-                    'allocated': allocated, 'limit': limit}
-        self.assertEqual(expected, show_res['quota_set'][resource])
-
-    def test_project_allocated_considered_on_reserve(self):
-        def _reserve(project_id):
-            quotas.QUOTAS._driver.reserve(
-                self.req.environ['cinder.context'], quotas.QUOTAS.resources,
-                {'volumes': 1}, project_id=project_id)
-
-        # A's quota will default to 10 for volumes
-        quota = {'volumes': 5}
-        body = {'quota_set': quota}
-        self.controller.update(self.req, self.B.id, body)
-        self._assert_quota_show(self.A.id, 'volumes', allocated=5, limit=10)
-        quota['volumes'] = 3
-        self.controller.update(self.req, self.C.id, body)
-        self._assert_quota_show(self.A.id, 'volumes', allocated=8, limit=10)
-        _reserve(self.A.id)
-        _reserve(self.A.id)
-        self.assertRaises(exception.OverQuota, _reserve, self.A.id)
-
-    def test_update_parent_project_lower_than_child(self):
-        # A's quota will be default of 10
-        quota = {'volumes': 10}
-        body = {'quota_set': quota}
-        self.controller.update(self.req, self.B.id, body)
-        quota['volumes'] = 9
-        self.assertRaises(webob.exc.HTTPBadRequest,
-                          self.controller.update, self.req, self.A.id, body)
-
-    def test_project_delete_with_default_quota_less_than_in_use(self):
-        quota = {'volumes': 11}
-        body = {'quota_set': quota}
-        self.controller.update(self.req, self.A.id, body)
-        quotas.QUOTAS._driver.reserve(
-            self.req.environ['cinder.context'], quotas.QUOTAS.resources,
-            quota, project_id=self.A.id)
-        # Should not be able to delete if it will cause the used values to go
-        # over quota when nested quotas are used
-        self.assertRaises(webob.exc.HTTPBadRequest,
-                          self.controller.delete,
-                          self.req,
-                          self.A.id)
-
-    def test_subproject_delete_with_default_quota_less_than_in_use(self):
-        quota = {'volumes': 1}
-        body = {'quota_set': quota}
-        self.controller.update(self.req, self.B.id, body)
-        quotas.QUOTAS._driver.reserve(
-            self.req.environ['cinder.context'], quotas.QUOTAS.resources,
-            quota, project_id=self.B.id)
-
-        # Should not be able to delete if it will cause the used values to go
-        # over quota when nested quotas are used
-        self.assertRaises(webob.exc.HTTPBadRequest,
-                          self.controller.delete,
-                          self.req,
-                          self.B.id)
+        result = self.controller.update(self.req, self.project_d['id'], body)
+        self.assertEqual(body, result)
 
     def test_subproject_delete(self):
-        self.req.environ['cinder.context'].project_id = self.A.id
-
-        body = make_body(gigabytes=2000, snapshots=15, volumes=5, backups=5,
+        body = make_body(gigabytes=2000, snapshots=15,
+                         volumes=5, backups=5,
                          backup_gigabytes=1000, tenant_id=None)
-        result_update = self.controller.update(self.req, self.A.id, body)
-        self.assertDictMatch(body, result_update)
+        result_update = self.controller.update(
+            self.req, self.project_a['id'], body)
+        self.assertEqual(result_update, body)
 
         # Set usage param to True in order to see get allocated values.
         self.req.params = {'usage': 'True'}
-        result_show = self.controller.show(self.req, self.A.id)
-
-        result_update = self.controller.update(self.req, self.B.id, body)
-        self.assertDictMatch(body, result_update)
-
-        self.controller.delete(self.req, self.B.id)
+        result_show = self.controller.show(self.req, self.project_a['id'])
 
-        result_show_after = self.controller.show(self.req, self.A.id)
-        self.assertDictMatch(result_show, result_show_after)
+        result_update = self.controller.update(
+            self.req, self.project_b['id'], body)
+        self.assertEqual(result_update, body)
 
-    def test_subproject_delete_not_considering_default_quotas(self):
-        """Test delete subprojects' quotas won't consider default quotas.
-
-        Test plan:
-        - Update the volume quotas of project A
-        - Update the volume quotas of project B
-        - Delete the quotas of project B
-
-        Resources with default quotas aren't expected to be considered when
-        updating the allocated values of the parent project. Thus, the delete
-        operation should succeed.
-        """
-        self.req.environ['cinder.context'].project_id = self.A.id
-
-        body = {'quota_set': {'volumes': 5}}
-        result = self.controller.update(self.req, self.A.id, body)
-        self.assertEqual(body['quota_set']['volumes'],
-                         result['quota_set']['volumes'])
-
-        body = {'quota_set': {'volumes': 2}}
-        result = self.controller.update(self.req, self.B.id, body)
-        self.assertEqual(body['quota_set']['volumes'],
-                         result['quota_set']['volumes'])
-
-        self.controller.delete(self.req, self.B.id)
-
-    def test_subproject_delete_with_child_present(self):
-        # Update the project A quota.
-        self.req.environ['cinder.context'].project_id = self.A.id
-        body = make_body(volumes=5)
-        self.controller.update(self.req, self.A.id, body)
-
-        # Allocate some of that quota to a child project
-        body = make_body(volumes=3)
-        self.controller.update(self.req, self.B.id, body)
-
-        # Deleting 'A' should be disallowed since 'B' is using some of that
-        # quota
-        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.delete,
-                          self.req, self.A.id)
-
-    def test_subproject_delete_with_child_updates_parent_allocated(self):
-        quota = {'volumes': 5}
-        body = {'quota_set': quota}
-        self.controller.update(self.req, self.A.id, body)
-
-        # Allocate some of that quota to a child project using hard limit
-        quota['volumes'] = -1
-        self.controller.update(self.req, self.B.id, body)
-        quota['volumes'] = 2
-        self.controller.update(self.req, self.D.id, body)
-
-        res = 'volumes'
-        self._assert_quota_show(self.A.id, res, allocated=2, limit=5)
-        self._assert_quota_show(self.B.id, res, allocated=2, limit=-1)
-        self.controller.delete(self.req, self.D.id)
-        self._assert_quota_show(self.A.id, res, allocated=0, limit=5)
-        self._assert_quota_show(self.B.id, res, allocated=0, limit=-1)
-
-    def test_negative_child_limit_not_affecting_parents_free_quota(self):
-        quota = {'volumes': -1}
-        body = {'quota_set': quota}
-        self.controller.update(self.req, self.C.id, body)
-        self.controller.update(self.req, self.B.id, body)
-
-        # Shouldn't be able to set greater than parent
-        quota['volumes'] = 11
-        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.update,
-                          self.req, self.B.id, body)
-
-    def test_child_neg_limit_set_grandkid_zero_limit(self):
-        cur_quota_a = self.controller.show(self.req, self.A.id)
-        self.assertEqual(10, cur_quota_a['quota_set']['volumes'])
-
-        quota = {'volumes': -1}
-        body = {'quota_set': quota}
-        self.controller.update(self.req, self.B.id, body)
-
-        cur_quota_d = self.controller.show(self.req, self.D.id)
-        # Default child value is 0
-        self.assertEqual(0, cur_quota_d['quota_set']['volumes'])
-        # Should be able to set D explicitly to 0 since that's already the val
-        quota['volumes'] = 0
-        self.controller.update(self.req, self.D.id, body)
-
-    def test_grandkid_negative_one_limit_enforced(self):
-        quota = {'volumes': 2, 'gigabytes': 2}
-        body = {'quota_set': quota}
-        self.controller.update(self.req, self.A.id, body)
-
-        quota['volumes'] = -1
-        quota['gigabytes'] = -1
-        self.controller.update(self.req, self.B.id, body)
-        self.controller.update(self.req, self.C.id, body)
-        self.controller.update(self.req, self.D.id, body)
-
-        def _reserve(project_id):
-            quotas.QUOTAS._driver.reserve(
-                self.req.environ['cinder.context'], quotas.QUOTAS.resources,
-                {'volumes': 1, 'gigabytes': 1}, project_id=project_id)
-
-        _reserve(self.C.id)
-        _reserve(self.D.id)
-        self.assertRaises(exception.OverQuota, _reserve, self.B.id)
-        self.assertRaises(exception.OverQuota, _reserve, self.C.id)
-        self.assertRaises(exception.OverQuota, _reserve, self.D.id)
-
-        # Make sure the rollbacks went successfully for allocated for all res
-        for res in quota.keys():
-            self._assert_quota_show(self.A.id, res, allocated=2, limit=2)
-            self._assert_quota_show(self.B.id, res, allocated=1, limit=-1)
-            self._assert_quota_show(self.C.id, res, reserved=1, limit=-1)
-            self._assert_quota_show(self.D.id, res, reserved=1, limit=-1)
-
-    def test_child_update_affects_allocated_and_rolls_back(self):
-        quota = {'gigabytes': -1, 'volumes': 3}
-        body = {'quota_set': quota}
-        self.controller.update(self.req, self.A.id, body)
-        quota['volumes'] = -1
-        self.controller.update(self.req, self.B.id, body)
-        quota['volumes'] = 1
-        self.controller.update(self.req, self.C.id, body)
-
-        # Shouldn't be able to update to greater than the grandparent
-        quota['volumes'] = 3
-        quota['gigabytes'] = 1
-        self.assertRaises(webob.exc.HTTPBadRequest,
-                          self.controller.update, self.req, self.D.id, body)
-        # Validate we haven't updated either parents' allocated value for
-        # any of the keys (even if some keys were valid)
-        self._assert_quota_show(self.A.id, 'volumes', allocated=1, limit=3)
-        self._assert_quota_show(self.A.id, 'gigabytes', limit=-1)
-        self._assert_quota_show(self.B.id, 'volumes', limit=-1)
-        self._assert_quota_show(self.B.id, 'gigabytes', limit=-1)
-
-        quota['volumes'] = 2
-        self.controller.update(self.req, self.D.id, body)
-        # Validate we have now updated the parent and grandparents'
-        self.req.params = {'usage': 'True'}
-        self._assert_quota_show(self.A.id, 'volumes', allocated=3, limit=3)
-        self._assert_quota_show(self.A.id, 'gigabytes', allocated=1, limit=-1)
-        self._assert_quota_show(self.B.id, 'volumes', allocated=2, limit=-1)
-        self._assert_quota_show(self.B.id, 'gigabytes', allocated=1, limit=-1)
-
-    def test_negative_child_limit_reserve_and_rollback(self):
-        quota = {'volumes': 2, 'gigabytes': 2}
-        body = {'quota_set': quota}
-        self.controller.update(self.req, self.A.id, body)
-
-        quota['volumes'] = -1
-        quota['gigabytes'] = -1
-        self.controller.update(self.req, self.B.id, body)
-        self.controller.update(self.req, self.C.id, body)
-        self.controller.update(self.req, self.D.id, body)
-
-        res = quotas.QUOTAS._driver.reserve(
-            self.req.environ['cinder.context'], quotas.QUOTAS.resources,
-            {'volumes': 2, 'gigabytes': 2}, project_id=self.D.id)
-
-        self.req.params = {'usage': 'True'}
-        quota_b = self.controller.show(self.req, self.B.id)
-        self.assertEqual(2, quota_b['quota_set']['volumes']['allocated'])
-        # A will be the next hard limit to set
-        quota_a = self.controller.show(self.req, self.A.id)
-        self.assertEqual(2, quota_a['quota_set']['volumes']['allocated'])
-        quota_d = self.controller.show(self.req, self.D.id)
-        self.assertEqual(2, quota_d['quota_set']['volumes']['reserved'])
-
-        quotas.QUOTAS.rollback(self.req.environ['cinder.context'], res,
-                               self.D.id)
-        # After the rollback, A's limit should be properly set again
-        quota_a = self.controller.show(self.req, self.A.id)
-        self.assertEqual(0, quota_a['quota_set']['volumes']['allocated'])
-        quota_d = self.controller.show(self.req, self.D.id)
-        self.assertEqual(0, quota_d['quota_set']['volumes']['in_use'])
-
-    @mock.patch('cinder.db.sqlalchemy.api._get_quota_usages')
-    @mock.patch('cinder.db.quota_usage_get_all_by_project')
-    def test_nested_quota_set_negative_limit(self, mock_usage, mock_get_usage):
-        # TODO(mc_nair): this test should be moved to Tempest once nested quota
-        # coverage is added
-        fake_usages = {self.A.id: 1, self.B.id: 1, self.D.id: 2, self.C.id: 0}
-        self._create_fake_quota_usages(fake_usages)
-        mock_usage.side_effect = self._fake_quota_usage_get_all_by_project
-
-        class FakeUsage(object):
-                def __init__(self, in_use, reserved):
-                    self.in_use = in_use
-                    self.reserved = reserved
-                    self.until_refresh = None
-                    self.total = self.reserved + self.in_use
-
-        def _fake__get_quota_usages(context, session, project_id):
-            if not project_id:
-                return {}
-            return {'volumes': FakeUsage(fake_usages[project_id], 0)}
-        mock_get_usage.side_effect = _fake__get_quota_usages
-
-        # Update the project A quota.
-        quota_limit = {'volumes': 7}
-        body = {'quota_set': quota_limit}
-        self.controller.update(self.req, self.A.id, body)
-
-        quota_limit['volumes'] = 4
-        self.controller.update(self.req, self.B.id, body)
-        quota_limit['volumes'] = -1
-        self.controller.update(self.req, self.D.id, body)
-
-        quota_limit['volumes'] = 1
-        self.controller.update(self.req, self.C.id, body)
-
-        self.req.params['fix_allocated_quotas'] = True
-        self.controller.validate_setup_for_nested_quota_use(self.req)
-
-        # Validate that the allocated values look right for each project
-        self.req.params = {'usage': 'True'}
+        self.controller.delete(self.req, self.project_b['id'])
 
-        res = 'volumes'
-        # A has given 4 vols to B and 1 vol to C (from limits)
-        self._assert_quota_show(self.A.id, res, allocated=5, in_use=1, limit=7)
-        self._assert_quota_show(self.B.id, res, allocated=2, in_use=1, limit=4)
-        self._assert_quota_show(self.D.id, res, in_use=2, limit=-1)
-        self._assert_quota_show(self.C.id, res, limit=1)
-
-        # Update B to -1 limit, and make sure that A's allocated gets updated
-        # with B + D's in_use values (one less than current limit
-        quota_limit['volumes'] = -1
-        self.controller.update(self.req, self.B.id, body)
-        self._assert_quota_show(self.A.id, res, allocated=4, in_use=1, limit=7)
-
-        quota_limit['volumes'] = 6
-        self.assertRaises(
-            webob.exc.HTTPBadRequest,
-            self.controller.update, self.req, self.B.id, body)
-
-        quota_limit['volumes'] = 5
-        self.controller.update(self.req, self.B.id, body)
-        self._assert_quota_show(self.A.id, res, allocated=6, in_use=1, limit=7)
+        result_show_after = self.controller.show(
+            self.req, self.project_a['id'])
+        self.assertEqual(result_show, result_show_after)
diff --git a/cinder/tests/unit/test_quota.py b/cinder/tests/unit/test_quota.py
index 016a597d8..b9b71723d 100644
--- a/cinder/tests/unit/test_quota.py
+++ b/cinder/tests/unit/test_quota.py
@@ -361,9 +361,11 @@ class FakeDriver(object):
         return resources
 
     def get_project_quotas(self, context, resources, project_id,
-                           quota_class=None, defaults=True, usages=True):
+                           quota_class=None, defaults=True, usages=True,
+                           parent_project_id=None):
         self.called.append(('get_project_quotas', context, resources,
-                            project_id, quota_class, defaults, usages))
+                            project_id, quota_class, defaults, usages,
+                            parent_project_id))
         return resources
 
     def limit_check(self, context, resources, values, project_id=None):
@@ -476,6 +478,16 @@ class BaseResourceTestCase(test.TestCase):
 
         self.assertEqual(0, quota_value)
 
+    def test_quota_override_subproject_no_class(self):
+        self.flags(quota_volumes=10)
+        resource = quota.BaseResource('test_resource', 'quota_volumes',
+                                      parent_project_id='test_parent_project')
+        driver = FakeDriver()
+        context = FakeContext('test_project', None)
+        quota_value = resource.quota(driver, context)
+
+        self.assertEqual(quota_value, 0)
+
     def test_quota_with_project_override_class(self):
         self.flags(quota_volumes=10)
         resource = quota.BaseResource('test_resource', 'quota_volumes')
@@ -587,11 +599,11 @@ class QuotaEngineTestCase(test.TestCase):
         quota_obj = self._make_quota_obj(driver)
         result = quota_obj.get_defaults(context)
 
-        self.assertEqual([('get_defaults',
-                          context,
-                          quota_obj.resources,
-                          parent_project_id), ], driver.called)
-        self.assertEqual(quota_obj.resources, result)
+        self.assertEqual(driver.called, [('get_defaults',
+                                          context,
+                                          quota_obj.resources,
+                                          parent_project_id), ])
+        self.assertEqual(result, quota_obj.resources)
 
     def test_get_class_quotas(self):
         context = FakeContext(None, None)
@@ -614,6 +626,7 @@ class QuotaEngineTestCase(test.TestCase):
     def test_get_project_quotas(self):
         context = FakeContext(None, None)
         driver = FakeDriver()
+        parent_project_id = None
         quota_obj = self._make_quota_obj(driver)
         result1 = quota_obj.get_project_quotas(context, 'test_project')
         result2 = quota_obj.get_project_quotas(context, 'test_project',
@@ -621,51 +634,60 @@ class QuotaEngineTestCase(test.TestCase):
                                                defaults=False,
                                                usages=False)
 
-        self.assertEqual([
+        self.assertEqual(driver.called, [
             ('get_project_quotas',
              context,
              quota_obj.resources,
              'test_project',
              None,
              True,
-             True),
+             True,
+             parent_project_id),
             ('get_project_quotas',
              context,
              quota_obj.resources,
              'test_project',
              'test_class',
              False,
-             False), ], driver.called)
-        self.assertEqual(quota_obj.resources, result1)
-        self.assertEqual(quota_obj.resources, result2)
+             False,
+             parent_project_id), ])
+        self.assertEqual(result1, quota_obj.resources)
+        self.assertEqual(result2, quota_obj.resources)
 
     def test_get_subproject_quotas(self):
         context = FakeContext(None, None)
         driver = FakeDriver()
+        parent_project_id = 'test_parent_project_id'
         quota_obj = self._make_quota_obj(driver)
-        result1 = quota_obj.get_project_quotas(context, 'test_project')
+        result1 = quota_obj.get_project_quotas(context, 'test_project',
+                                               parent_project_id=
+                                               parent_project_id)
         result2 = quota_obj.get_project_quotas(context, 'test_project',
                                                quota_class='test_class',
                                                defaults=False,
-                                               usages=False)
+                                               usages=False,
+                                               parent_project_id=
+                                               parent_project_id)
 
-        self.assertEqual([
+        self.assertEqual(driver.called, [
             ('get_project_quotas',
              context,
              quota_obj.resources,
              'test_project',
              None,
              True,
-             True),
+             True,
+             parent_project_id),
             ('get_project_quotas',
              context,
              quota_obj.resources,
              'test_project',
              'test_class',
              False,
-             False), ], driver.called)
-        self.assertEqual(quota_obj.resources, result1)
-        self.assertEqual(quota_obj.resources, result2)
+             False,
+             parent_project_id), ])
+        self.assertEqual(result1, quota_obj.resources)
+        self.assertEqual(result2, quota_obj.resources)
 
     def test_count_no_resource(self):
         context = FakeContext(None, None)
@@ -883,9 +905,9 @@ class VolumeTypeQuotaEngineTestCase(test.TestCase):
         engine.update_quota_resource(ctx, 'type1', 'type2')
 
 
-class DbQuotaDriverBaseTestCase(test.TestCase):
+class DbQuotaDriverTestCase(test.TestCase):
     def setUp(self):
-        super(DbQuotaDriverBaseTestCase, self).setUp()
+        super(DbQuotaDriverTestCase, self).setUp()
 
         self.flags(quota_volumes=10,
                    quota_snapshots=10,
@@ -897,21 +919,8 @@ class DbQuotaDriverBaseTestCase(test.TestCase):
                    max_age=0,
                    )
 
-        # These can be used for expected defaults for child/non-child
-        self._default_quotas_non_child = dict(
-            volumes=10,
-            snapshots=10,
-            gigabytes=1000,
-            backups=10,
-            backup_gigabytes=1000,
-            per_volume_gigabytes=-1)
-        self._default_quotas_child = dict(
-            volumes=0,
-            snapshots=0,
-            gigabytes=0,
-            backups=0,
-            backup_gigabytes=0,
-            per_volume_gigabytes=0)
+        self.driver = quota.DbQuotaDriver()
+
 
         self.calls = []
 
@@ -920,6 +929,41 @@ class DbQuotaDriverBaseTestCase(test.TestCase):
         self.mock_utcnow = patcher.start()
         self.mock_utcnow.return_value = datetime.datetime.utcnow()
 
+    def test_get_defaults(self):
+        # Use our pre-defined resources
+        self._stub_quota_class_get_default()
+        self._stub_volume_type_get_all()
+        result = self.driver.get_defaults(None, quota.QUOTAS.resources)
+
+        self.assertEqual(
+            result,
+            dict(
+                volumes=10,
+                snapshots=10,
+                gigabytes=1000,
+                backups=10,
+                backup_gigabytes=1000,
+                per_volume_gigabytes=-1))
+
+    def test_subproject_get_defaults(self):
+        # Test subproject default values.
+        self._stub_quota_class_get_default_subproject()
+        self._stub_volume_type_get_all()
+        parent_project_id = 'test_parent_project_id'
+        result = self.driver.get_defaults(None,
+                                          quota.QUOTAS.resources,
+                                          parent_project_id)
+
+        self.assertEqual(
+            result,
+            dict(
+                volumes=0,
+                snapshots=0,
+                gigabytes=0,
+                backups=0,
+                backup_gigabytes=0,
+                per_volume_gigabytes=0))
+
     def _stub_quota_class_get_default(self):
         # Stub out quota_class_get_default
         def fake_qcgd(context):
@@ -932,6 +976,13 @@ class DbQuotaDriverBaseTestCase(test.TestCase):
                         )
         self.stubs.Set(db, 'quota_class_get_default', fake_qcgd)
 
+    def _stub_quota_class_get_default_subproject(self):
+        # Stub out quota_class_get_default for subprojects
+        def fake_qcgd(context):
+            self.calls.append('quota_class_get_default')
+            return {}
+        self.stubs.Set(db, 'quota_class_get_default', fake_qcgd)
+
     def _stub_volume_type_get_all(self):
         def fake_vtga(context, inactive=False, filters=None):
             return {}
@@ -955,28 +1006,6 @@ class DbQuotaDriverBaseTestCase(test.TestCase):
 
         self.stubs.Set(db, 'quota_allocated_get_all_by_project', fake_qagabp)
 
-
-class DbQuotaDriverTestCase(DbQuotaDriverBaseTestCase):
-    def setUp(self):
-        super(DbQuotaDriverTestCase, self).setUp()
-
-        self.driver = quota.DbQuotaDriver()
-
-    def test_get_defaults(self):
-        # Use our pre-defined resources
-        self._stub_quota_class_get_default()
-        self._stub_volume_type_get_all()
-        result = self.driver.get_defaults(None, quota.QUOTAS.resources)
-
-        self.assertEqual(
-            dict(
-                volumes=10,
-                snapshots=10,
-                gigabytes=1000,
-                backups=10,
-                backup_gigabytes=1000,
-                per_volume_gigabytes=-1), result)
-
     def test_get_class_quotas(self):
         self._stub_quota_class_get_all_by_name()
         self._stub_volume_type_get_all()
@@ -1027,6 +1056,34 @@ class DbQuotaDriverTestCase(DbQuotaDriverBaseTestCase):
         self._stub_quota_class_get_all_by_name()
         self._stub_quota_class_get_default()
 
+    def _stub_get_by_subproject(self):
+        def fake_qgabp(context, project_id):
+            self.calls.append('quota_get_all_by_project')
+            self.assertEqual(project_id, 'test_project')
+            return dict(volumes=10, gigabytes=50, reserved=0)
+
+        def fake_qugabp(context, project_id):
+            self.calls.append('quota_usage_get_all_by_project')
+            self.assertEqual(project_id, 'test_project')
+            return dict(volumes=dict(in_use=2, reserved=0),
+                        gigabytes=dict(in_use=10, reserved=0))
+
+        self.stubs.Set(db, 'quota_get_all_by_project', fake_qgabp)
+        self.stubs.Set(db, 'quota_usage_get_all_by_project', fake_qugabp)
+
+        self._stub_quota_class_get_all_by_name()
+        self._stub_quota_class_get_default_subproject()
+
+    def _stub_allocated_get_all_by_project(self, allocated_quota=False):
+        def fake_qagabp(context, project_id):
+            self.calls.append('quota_allocated_get_all_by_project')
+            self.assertEqual('test_project', project_id)
+            if allocated_quota:
+                return dict(project_id=project_id, volumes=3)
+            return dict(project_id=project_id)
+
+        self.stubs.Set(db, 'quota_allocated_get_all_by_project', fake_qagabp)
+
     def test_get_project_quotas(self):
         self._stub_get_by_project()
         self._stub_volume_type_get_all()
@@ -1060,24 +1117,6 @@ class DbQuotaDriverTestCase(DbQuotaDriverBaseTestCase):
                                                         reserved= 0)
                               ), result)
 
-    @mock.patch('cinder.quota.db.quota_get_all_by_project')
-    @mock.patch('cinder.quota.db.quota_class_get_default')
-    def test_get_project_quotas_lazy_load_defaults(
-            self, mock_defaults, mock_quotas):
-        mock_quotas.return_value = self._default_quotas_non_child
-        self.driver.get_project_quotas(
-            FakeContext('test_project', None),
-            quota.QUOTAS.resources, 'test_project', usages=False)
-        # Shouldn't load a project's defaults if all the quotas are already
-        # defined in the DB
-        self.assertFalse(mock_defaults.called)
-
-        mock_quotas.return_value = {}
-        self.driver.get_project_quotas(
-            FakeContext('test_project', None),
-            quota.QUOTAS.resources, 'test_project', usages=False)
-        self.assertTrue(mock_defaults.called)
-
     def test_get_root_project_with_subprojects_quotas(self):
         self._stub_get_by_project()
         self._stub_volume_type_get_all()
@@ -1116,6 +1155,46 @@ class DbQuotaDriverTestCase(DbQuotaDriverBaseTestCase):
                                                         allocated=0)
                               ), result)
 
+    def test_get_subproject_quotas(self):
+        self._stub_get_by_subproject()
+        self._stub_volume_type_get_all()
+        self._stub_allocated_get_all_by_project(allocated_quota=True)
+        parent_project_id = 'test_parent_project_id'
+        result = self.driver.get_project_quotas(
+            FakeContext('test_project', None),
+            quota.QUOTAS.resources, 'test_project',
+            parent_project_id=parent_project_id)
+
+        self.assertEqual(['quota_get_all_by_project',
+                          'quota_usage_get_all_by_project',
+                          'quota_allocated_get_all_by_project',
+                          'quota_class_get_default'], self.calls)
+        self.assertEqual(dict(volumes=dict(limit=10,
+                                           in_use=2,
+                                           reserved=0,
+                                           allocated=3, ),
+                              snapshots=dict(limit=0,
+                                             in_use=0,
+                                             reserved=0,
+                                             allocated=0, ),
+                              gigabytes=dict(limit=50,
+                                             in_use=10,
+                                             reserved=0,
+                                             allocated=0, ),
+                              backups=dict(limit=0,
+                                           in_use=0,
+                                           reserved=0,
+                                           allocated=0, ),
+                              backup_gigabytes=dict(limit=0,
+                                                    in_use=0,
+                                                    reserved=0,
+                                                    allocated=0, ),
+                              per_volume_gigabytes=dict(in_use=0,
+                                                        limit=0,
+                                                        reserved=0,
+                                                        allocated=0)
+                              ), result)
+
     def test_get_project_quotas_alt_context_no_class(self):
         self._stub_get_by_project()
         self._stub_volume_type_get_all()
@@ -1184,10 +1263,12 @@ class DbQuotaDriverTestCase(DbQuotaDriverBaseTestCase):
             FakeContext('test_project', 'test_class'),
             quota.QUOTAS.resources, 'test_project', defaults=False)
 
-        self.assertEqual(['quota_get_all_by_project',
-                          'quota_usage_get_all_by_project',
-                          'quota_class_get_all_by_name'], self.calls)
-        self.assertEqual(dict(backups=dict(limit=10,
+        self.assertEqual(self.calls, ['quota_get_all_by_project',
+                                      'quota_usage_get_all_by_project',
+                                      'quota_class_get_all_by_name',
+                                      'quota_class_get_default', ])
+        self.assertEqual(result,
+                         dict(backups=dict(limit=10,
                                            in_use=2,
                                            reserved=0, ),
                               backup_gigabytes=dict(limit=50,
@@ -1203,7 +1284,7 @@ class DbQuotaDriverTestCase(DbQuotaDriverBaseTestCase):
                                            in_use=2,
                                            reserved=0, ),
 
-                              ), result)
+                              ))
 
     def test_get_project_quotas_no_usages(self):
         self._stub_get_by_project()
@@ -1384,269 +1465,6 @@ class DbQuotaDriverTestCase(DbQuotaDriverBaseTestCase):
                          self.calls)
 
 
-class NestedDbQuotaDriverBaseTestCase(DbQuotaDriverBaseTestCase):
-    def setUp(self):
-        super(NestedDbQuotaDriverBaseTestCase, self).setUp()
-        self.context = context.RequestContext('user_id',
-                                              'project_id',
-                                              is_admin=True,
-                                              auth_token="fake_token")
-        self.auth_url = 'http://localhost:5000'
-        self._child_proj_id = 'child_id'
-        self._non_child_proj_id = 'non_child_id'
-
-        keystone_mock = mock.Mock()
-        keystone_mock.version = 'v3'
-
-        class FakeProject(object):
-            def __init__(self, parent_id):
-                self.parent_id = parent_id
-                self.parents = {parent_id: None}
-                self.domain_id = 'default'
-
-        def fake_get_project(project_id, subtree_as_ids=False,
-                             parents_as_ids=False):
-            # Enable imitation of projects with and without parents
-            if project_id == self._child_proj_id:
-                return FakeProject('parent_id')
-            else:
-                return FakeProject(None)
-
-        keystone_mock.projects.get.side_effect = fake_get_project
-
-        def _keystone_mock(self):
-            return keystone_mock
-
-        keystone_patcher = mock.patch('cinder.quota_utils._keystone_client',
-                                      _keystone_mock)
-        keystone_patcher.start()
-        self.addCleanup(keystone_patcher.stop)
-
-        self.fixture = self.useFixture(config_fixture.Config(CONF))
-        self.fixture.config(auth_uri=self.auth_url, group='keystone_authtoken')
-        self.driver = quota.NestedDbQuotaDriver()
-
-    def _stub_get_by_subproject(self):
-        def fake_qgabp(context, project_id):
-            self.calls.append('quota_get_all_by_project')
-            return dict(volumes=10, gigabytes=50, reserved=0)
-
-        def fake_qugabp(context, project_id):
-            self.calls.append('quota_usage_get_all_by_project')
-            return dict(volumes=dict(in_use=2, reserved=0),
-                        gigabytes=dict(in_use=10, reserved=0))
-
-        self.stubs.Set(db, 'quota_get_all_by_project', fake_qgabp)
-        self.stubs.Set(db, 'quota_usage_get_all_by_project', fake_qugabp)
-
-        self._stub_quota_class_get_all_by_name()
-
-
-class NestedDbQuotaDriverTestCase(NestedDbQuotaDriverBaseTestCase):
-    def test_get_defaults(self):
-        self._stub_volume_type_get_all()
-
-        # Test for child project defaults
-        result = self.driver.get_defaults(self.context,
-                                          quota.QUOTAS.resources,
-                                          self._child_proj_id)
-        self.assertEqual(self._default_quotas_child, result)
-
-        # Test for non-child project defaults
-        result = self.driver.get_defaults(self.context,
-                                          quota.QUOTAS.resources,
-                                          self._non_child_proj_id)
-        self.assertEqual(self._default_quotas_non_child, result)
-
-    def test_subproject_enforce_defaults(self):
-        # Non-child defaults should allow volume to get created
-        self.driver.reserve(self.context,
-                            quota.QUOTAS.resources,
-                            {'volumes': 1, 'gigabytes': 1},
-                            project_id=self._non_child_proj_id)
-
-        # Child defaults should not allow volume to be created
-        self.assertRaises(exception.OverQuota,
-                          self.driver.reserve, self.context,
-                          quota.QUOTAS.resources,
-                          {'volumes': 1, 'gigabytes': 1},
-                          project_id=self._child_proj_id)
-
-    def test_get_subproject_quotas(self):
-        self._stub_get_by_subproject()
-        self._stub_volume_type_get_all()
-        self._stub_allocated_get_all_by_project(allocated_quota=True)
-        result = self.driver.get_project_quotas(
-            self.context,
-            quota.QUOTAS.resources, self._child_proj_id)
-
-        self.assertEqual(['quota_get_all_by_project',
-                          'quota_usage_get_all_by_project',
-                          'quota_allocated_get_all_by_project', ], self.calls)
-        self.assertEqual(dict(volumes=dict(limit=10,
-                                           in_use=2,
-                                           reserved=0,
-                                           allocated=3, ),
-                              snapshots=dict(limit=0,
-                                             in_use=0,
-                                             reserved=0,
-                                             allocated=0, ),
-                              gigabytes=dict(limit=50,
-                                             in_use=10,
-                                             reserved=0,
-                                             allocated=0, ),
-                              backups=dict(limit=0,
-                                           in_use=0,
-                                           reserved=0,
-                                           allocated=0, ),
-                              backup_gigabytes=dict(limit=0,
-                                                    in_use=0,
-                                                    reserved=0,
-                                                    allocated=0, ),
-                              per_volume_gigabytes=dict(in_use=0,
-                                                        limit=0,
-                                                        reserved=0,
-                                                        allocated=0)
-                              ), result)
-
-
-class NestedQuotaValidation(NestedDbQuotaDriverBaseTestCase):
-    def setUp(self):
-        super(NestedQuotaValidation, self).setUp()
-        """
-        Quota hierarchy setup like so
-        +-----------+
-        |           |
-        |     A     |
-        |    / \    |
-        |   B   C   |
-        |  /        |
-        | D         |
-        +-----------+
-        """
-        self.project_tree = {'A': {'B': {'D': None}, 'C': None}}
-        self.proj_vals = {
-            'A': {'limit': 7, 'in_use': 1, 'alloc': 6},
-            'B': {'limit': 3, 'in_use': 1, 'alloc': 2},
-            'D': {'limit': 2, 'in_use': 0},
-            'C': {'limit': 3, 'in_use': 3},
-        }
-
-        # Just using one resource currently for simplicity of test
-        self.resources = {'volumes': quota.ReservableResource(
-            'volumes', '_sync_volumes', 'quota_volumes')}
-
-        to_patch = [('cinder.db.quota_allocated_get_all_by_project',
-                     self._fake_quota_allocated_get_all_by_project),
-                    ('cinder.db.quota_get_all_by_project',
-                     self._fake_quota_get_all_by_project),
-                    ('cinder.db.quota_usage_get_all_by_project',
-                     self._fake_quota_usage_get_all_by_project)]
-
-        for patch_path, patch_obj in to_patch:
-            patcher = mock.patch(patch_path, patch_obj)
-            patcher.start()
-            self.addCleanup(patcher.stop)
-
-    def _fake_quota_get_all_by_project(self, context, project_id):
-        return {'volumes': self.proj_vals[project_id]['limit']}
-
-    def _fake_quota_usage_get_all_by_project(self, context, project_id):
-        return {'volumes': self.proj_vals[project_id]}
-
-    def _fake_quota_allocated_get_all_by_project(self, context, project_id):
-        ret = {'project_id': project_id}
-        proj_val = self.proj_vals[project_id]
-        if 'alloc' in proj_val:
-            ret['volumes'] = proj_val['alloc']
-        return ret
-
-    def test_validate_nested_quotas(self):
-        self.driver.validate_nested_setup(self.context,
-                                          self.resources, self.project_tree)
-
-        # Fail because 7 - 2 < 3 + 3
-        self.proj_vals['A']['in_use'] = 2
-        self.assertRaises(exception.InvalidNestedQuotaSetup,
-                          self.driver.validate_nested_setup,
-                          self.context,
-                          self.resources, self.project_tree)
-        self.proj_vals['A']['in_use'] = 1
-
-        # Fail because 7 - 1 < 3 + 7
-        self.proj_vals['C']['limit'] = 7
-        self.assertRaises(exception.InvalidNestedQuotaSetup,
-                          self.driver.validate_nested_setup,
-                          self.context,
-                          self.resources, self.project_tree)
-        self.proj_vals['C']['limit'] = 3
-
-        # Fail because 3 < 4
-        self.proj_vals['D']['limit'] = 4
-        self.assertRaises(exception.InvalidNestedQuotaSetup,
-                          self.driver.validate_nested_setup,
-                          self.context,
-                          self.resources, self.project_tree)
-        self.proj_vals['D']['limit'] = 2
-
-    def test_validate_nested_quotas_usage_over_limit(self):
-        self.proj_vals['D']['in_use'] = 5
-        self.assertRaises(exception.InvalidNestedQuotaSetup,
-                          self.driver.validate_nested_setup,
-                          self.context, self.resources, self.project_tree)
-
-    def test_validate_nested_quota_bad_allocated_quotas(self):
-        self.proj_vals['A']['alloc'] = 5
-        self.proj_vals['B']['alloc'] = 8
-        self.assertRaises(exception.InvalidNestedQuotaSetup,
-                          self.driver.validate_nested_setup,
-                          self.context, self.resources, self.project_tree)
-
-    def test_validate_nested_quota_negative_child_limits(self):
-        # Redefining the project limits with -1, doing it all in this test
-        # for readability
-        self.proj_vals = {
-            'A': {'limit': 8, 'in_use': 1},
-            'B': {'limit': -1, 'in_use': 3},
-            'D': {'limit': 4, 'in_use': 0},
-            'C': {'limit': 2, 'in_use': 2},
-        }
-
-        # A's child usage is 3 (from B) + 4 (from D) + 2 (from C) = 9
-        self.assertRaises(exception.InvalidNestedQuotaSetup,
-                          self.driver.validate_nested_setup,
-                          self.context, self.resources, self.project_tree)
-
-        self.proj_vals['D']['limit'] = 2
-        self.driver.validate_nested_setup(
-            self.context, self.resources, self.project_tree,
-            fix_allocated_quotas=True)
-
-    def test_get_cur_project_allocated(self):
-        # Redefining the project limits with -1, doing it all in this test
-        # for readability
-        self.proj_vals = {
-            # Allocated are here to simulate a bad existing value
-            'A': {'limit': 8, 'in_use': 1, 'alloc': 6},
-            'B': {'limit': -1, 'in_use': 3, 'alloc': 2},
-            'D': {'limit': 1, 'in_use': 0},
-            'C': {'limit': 2, 'in_use': 2},
-        }
-
-        self.driver._allocated = {}
-        allocated_a = self.driver._get_cur_project_allocated(
-            self.context, self.resources['volumes'],
-            self.project_tree)
-
-        # A's allocated will be:
-        #   2 (from C's limit) + 3 (from B's in-use) + 1 (from D's limit) = 6
-        self.assertEqual(6, allocated_a)
-
-        # B's allocated value should also be calculated and cached as part
-        # of A's calculation
-        self.assertEqual(1, self.driver._allocated['B']['volumes'])
-
-
 class FakeSession(object):
     def begin(self):
         return self
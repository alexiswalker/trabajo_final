diff --git a/Kernel/Smp2Adapter/Mdk/Container.h b/Kernel/Smp2Adapter/Mdk/Container.h
index 56d0972..0cc4482 100644
--- a/Kernel/Smp2Adapter/Mdk/Container.h
+++ b/Kernel/Smp2Adapter/Mdk/Container.h
@@ -31,6 +31,29 @@
 #include "Mdk/Component.h"
 #include "Smp/IContainer.h"
 #include "Smp/Management/IManagedContainer.h"
+#include <map>
+
+// ----------------------------------------------------------------------------
+// ---------------------------- Macros ----------------------------------------
+// ----------------------------------------------------------------------------
+
+// Iterate through all children of an SMP Container.
+// The container is assumed to be typed.
+// The iterator type is assumed to be the container name suffixed by "Iterator".
+// This is the style generated by SIMSAT 4 for SMP Containers.
+#define foreach_child(TYPE, INSTANCE, CONTAINER) \
+    TYPE INSTANCE; \
+    for (CONTAINER##Iterator _it = CONTAINER -> Begin(); (_it != CONTAINER -> End()) && ((INSTANCE = *_it) || true); ++_it)
+
+// Iterate through all elements of a std::vector<TYPE>.
+// The TYPE must fit the VECTOR element type.
+// The VECTOR is evaluated only once (it may be a function call).
+// A temporary variable _v_INSTANCE is used to store the vector.
+#define foreach_elem(TYPE, INSTANCE, VECTOR) \
+    TYPE INSTANCE; \
+    const std::vector< TYPE > _v_##INSTANCE = VECTOR; \
+    for (std::vector< TYPE >::const_iterator _it = _v_##INSTANCE . begin(); (_it != _v_##INSTANCE . end()) && ((INSTANCE = *_it) || true); ++_it)
+
 
 namespace Smp 
 { 
@@ -60,6 +83,10 @@ namespace Smp
             // ----------------------------------------------------------------
 
         private:
+            // to improve performance we define our own indexer
+            typedef std::map<std::string, Smp::UInt32> IndexCollection;
+            IndexCollection          m_Indexes;
+
             Smp::ComponentCollection m_components;  ///< Untyped references.
             ChildCollection          m_children;    ///< Typed references.
 
@@ -115,16 +142,10 @@ namespace Smp
             ///          component with the given name could be found.
             virtual Smp::IComponent* GetComponent(Smp::String8 name) const
             {
-                for (Smp::ComponentCollection::const_iterator it = m_components.begin();
-                    it != m_components.end();
-                    it++)
-                {
-                    Smp::IComponent* component = *it;
-                    if (component && strcmp(component->GetName(), name) == 0)
-                    {
-                        return component;
-                    }
-                }
+                // find the component using our index rather than iterating through a vector
+                IndexCollection::const_iterator iter = m_Indexes.find(std::string(name));
+                if( iter != m_Indexes.end() )
+                    return m_components[iter->second];
 
                 return NULL;
             }
@@ -138,7 +159,7 @@ namespace Smp
             /// @return Current number of contained components.
             virtual Smp::Int64 Count() const 
             { 
-                return (Smp::Int64) m_components.size(); 
+                return (Smp::Int64)m_components.size();
             }
 
             /// Iterator to iterate on contained components (typed!).
@@ -178,12 +199,38 @@ namespace Smp
                     ++it)
                 {
                     Smp::IComponent* component = *it;
-                    delete component;
+                    if (component != NULL)
+                    {
+                        delete component;
+                        component = NULL;
+                    }
                 }
                 
                 // Clear collections, thus deleting the references.
                 m_children.clear();
                 m_components.clear();
+                m_Indexes.clear();
+            }
+
+            /// Index function to access provider by its index.
+            /// param index Index of provider.
+            ComponentType* At(int index) const
+            {
+                if ((index >= 0) && (index < Count()))
+                {
+                    return m_children.at(index);
+                }
+                else
+                {
+                    return NULL;
+                }
+            }
+
+            /// Index operator to access provider by its index.
+            /// param index Index of provider.
+            ComponentType* operator[](int index) const
+            {
+                return At(index);
             }
 
         protected:
@@ -216,6 +263,9 @@ namespace Smp
 
                 // Save in untyped container
                 m_components.push_back(component);
+
+                // add component and vector index to our container to improve performance
+                m_Indexes.insert(IndexCollection::value_type(std::string(component->GetName()), m_components.size() - 1));
             }
         };
     }
@@ -228,8 +278,20 @@ namespace Smp
  ***********/
 
 //$Log: Container.h,v $
-//Revision 1.1  2009/03/25 14:56:42  sramasamy
-//SIMSAT 4.0.2 version.
+//Revision 1.8  2010-08-09 21:08:00  jowh
+//Exit scheduler gracefully by catching the SIMSAT Exit event
+//
+//Revision 1.7  2010-06-21 09:11:20  anda
+//Added check for null before delete
+//
+//Revision 1.6  2010-04-12 20:37:38  jowh
+//Merged REFA changes
+//
+//Revision 1.5  2010-04-09 14:50:26  jowh
+//Clear the indexers also when clearing the container
+//
+//Revision 1.4  2010-02-04 08:19:50  jowh
+//Performance improvements when searching for or retrieving child components
 //
 //Revision 1.3  2008/02/19 18:39:12  nin
 //SPR-721: Memory leak analysis of the SMP2 Adapter
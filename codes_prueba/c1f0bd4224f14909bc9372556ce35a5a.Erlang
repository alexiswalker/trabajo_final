%
% reia_rebinding: Support for operations that alter local variable bindings
% Copyright (C)2009 Tony Arcieri
%
% Redistribution is permitted under the MIT license.  See LICENSE for details.
%

-module(reia_rebinding).
-export([transform/2]).
-include("reia_nodes.hrl").

% Internal state of the rebinding transformation
-record(state, {exprs=[], count=0}).

transform(Exprs, _Options) ->
  reia_syntax:map_subtrees(fun transform_node/1, Exprs).

% Transform nodes that potentially rebind variables
transform_node(#binary_op{line=Line, type='+=', left=Left, right=Right}) ->
  rebind_op(Line, '+', Left, Right);
transform_node(#binary_op{line=Line, type='-=', left=Left, right=Right}) ->
  rebind_op(Line, '-', Left, Right);
transform_node(#binary_op{line=Line, type='*=', left=Left, right=Right}) ->
  rebind_op(Line, '*', Left, Right);
transform_node(#binary_op{line=Line, type='/=', left=Left, right=Right}) ->
  rebind_op(Line, '/', Left, Right);
transform_node(#binary_op{line=Line, type='**=', left=Left, right=Right}) ->
  rebind_op(Line, '**', Left, Right);
transform_node(#binary_op{line=Line, type='&=', left=Left, right=Right}) ->
  rebind_op(Line, '&', Left, Right);
transform_node(#binary_op{line=Line, type='|=', left=Left, right=Right}) ->
  rebind_op(Line, '|', Left, Right);
transform_node(#binary_op{line=Line, type='^=', left=Left, right=Right}) ->
  rebind_op(Line, '^', Left, Right);
transform_node(#binary_op{line=Line, type='<<=', left=Left, right=Right}) ->
  rebind_op(Line, '<<', Left, Right);
transform_node(#binary_op{line=Line, type='>>=', left=Left, right=Right}) ->
  rebind_op(Line, '>>', Left, Right);
transform_node(#match{} = Node) ->
  reia_syntax:map_subtrees(fun transform_node/1, transform_setters(Node));
transform_node(#remote_call{line=Line, name=Name, receiver=#var{} = Receiver} = Node) ->
  Node2 = reia_syntax:map_subtrees(fun transform_node/1, Node),

  % Handle 'bang' methods which modify their receivers
  [Last|Rest] = lists:reverse(atom_to_list(Name)),
  case Last of
    $! ->
      Name2 = list_to_atom(lists:reverse(Rest)),
      #match{line=Line, left=Receiver, right=Node2#remote_call{name=Name2}};
    _  -> 
      Node2
  end;
transform_node(#remote_call{line=Line, name=Name} = Node) ->
  [Last|_] = lists:reverse(atom_to_list(Name)),
  case Last of
    $! -> throw({error, {Line, "bang methods are not supported on literals"}});
    _  -> reia_syntax:map_subtrees(fun transform_node/1, Node)
  end;
transform_node(Node) ->
  reia_syntax:map_subtrees(fun transform_node/1, Node).

% Transform shorthand operations that rebind a variable
rebind_op(Line, Type, Left, Right) ->
  Node = #match{
    line=Line,
    left=Left,
    right=#binary_op{line=Line, type=Type, left=Left, right=Right}
  },
  
  % In case this node contains additional setters that need processing
  transform_node(Node).
  
%
% Transform expressions that behave differently in match scope
%

transform_setters(#match{line=Line, left=Left} = Node) ->
  % Transform any setters on the lhs of this match operation
  {[Left2], State} = reia_syntax:mapfold_subtrees(fun transform_setters/2, #state{}, [Left]),
  Match = Node#match{left=Left2},
  
  case State#state.exprs of
    [] ->
      Match;
    Exprs ->
      TmpVar = #var{line=Line, name='__match_placeholder'},
      OuterMatch = #match{line=Line, left=TmpVar, right=Match},
      #block{line=Line, exprs=lists:flatten([OuterMatch, Exprs, TmpVar])}
  end.

% This implements the []= method, which allows set operations on members of 
% maps, tuples, and dicts.  A new version of the receiver is generated by
% this function, then the new version is destructively rebound over the old. 
transform_setters(#binary_op{line=Line, type='[]', left=#var{}=Left, right=Right}, #state{exprs=Exprs, count=Count} = State) ->
  % Generate a temporary variable to use in the original match expression
  TmpVar = #var{line=Line, name=list_to_atom("__rebind_op_" ++ integer_to_list(Count))},
  
  % Invoke the []= method on the receiver, which will return the new version
  SetExpr = #remote_call{line=Line, receiver=Left, name='[]=', args=[Right, TmpVar], block=#nil{line=Line}},
  
  % Rebind the receiver to the new version
  RebindExpr = #match{line=Line, left=Left, right=SetExpr},
  
  {TmpVar, State#state{exprs=[RebindExpr|Exprs], count=Count+1}};
transform_setters(#binary_op{line=Line, type='[]'}, _State) ->
  throw({error, {Line, "illegal [] on a literal in a match expression"}});
transform_setters(Node, State) ->
  reia_syntax:mapfold_subtrees(fun transform_setters/2, State, Node).